<!DOCTYPE html>
<html>
<head>
    <title>JFR Query Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            padding-top: 0;
            padding-bottom: 0;
        }
        .controls-container {
            display: flex;
            margin-bottom: 10px;
            gap: 10px;
        }
        .query-area {
            flex-grow: 1;
        }
        #queryInput {
            width: 100%;
            font-family: monospace;
            padding: 8px;
            box-sizing: border-box;
            height: 100px;
        }
        #previousQueries {
            width: 100%;
            margin-bottom: 5px;
            padding: 5px;
        }
        .buttons {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            gap: 5px;
        }
        #executeButton {
            padding: 8px 15px;
        }
        .auto-query {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #result {
            font-family: monospace;
            white-space: pre-wrap;
            overflow-y: auto;
            height: calc(100vh - 250px);
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f5f5f5;
        }

        /* Syntax highlighting styles */
        .syntax-highlighter-wrapper {
            position: relative;
            width: 100%;
            height: 100px;
        }

        #highlightDiv {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            font-family: monospace;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            background-color: white;
            white-space: pre-wrap;
            overflow: hidden;
            pointer-events: none;
            z-index: 1;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        #queryInput.highlighted {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            font-family: monospace;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            background-color: transparent;
            color: transparent;
            caret-color: black;
            resize: none;
            z-index: 2;
        }

        .sql-keyword { color: #0066cc; font-weight: bold; }
        .sql-function { color: #cc6600; font-weight: bold; }
        .sql-string { color: #009900; }
        .sql-field { color: #660066; }
        .sql-operator { color: #cc0000; }
        .sql-number { color: #ff6600; }
        .sql-comment { color: #999999; font-style: italic; }

        .view-section {
            color: #0066cc;
            font-weight: bold;
            background-color: #f0f8ff;
            padding: 2px 4px;
            border-left: 3px solid #0066cc;
        }
        
        .view-label {
            color: #006600;
            font-weight: bold;
        }
        
        .view-comment {
            color: #999999;
            font-style: italic;
        }
        
        .view-query-type {
            color: #666666;
            font-weight: bold;
        }
        
        /* Enhanced result div to support HTML content */
        #result {
            font-family: monospace;
            white-space: pre-wrap;
            overflow-y: auto;
            height: calc(100vh - 250px);
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f5f5f5;
            line-height: 1.4;
        }

        /* Auto-completion styles */
        .autocomplete-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ccc;
            border-top: none;
            max-height: 300px; /* Increased for more suggestions */
            overflow-y: auto;
            z-index: 1000;
            display: none;
            font-size: 13px;
        }

        .autocomplete-suggestion {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.selected {
            background-color: #e6f3ff;
        }

        .suggestion-main {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px;
        }

        .suggestion-text {
            font-family: monospace;
            font-weight: 500;
            color: #333;
            flex: 1;
            word-break: break-all;
        }

        .suggestion-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
            flex-shrink: 0;
        }

        .autocomplete-suggestion-type {
            font-size: 0.75em;
            color: #666;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            text-transform: uppercase;
            font-weight: bold;
        }

        .suggestion-count {
            font-size: 0.7em;
            color: #007acc;
            font-weight: bold;
            background: #e8f4fd;
            padding: 1px 4px;
            border-radius: 2px;
        }

        .suggestion-description {
            font-size: 0.7em;
            color: #888;
            font-style: italic;
            text-align: right;
            max-width: 120px;
            word-wrap: break-word;
        }

        /* Color coding for different suggestion types */
        .autocomplete-suggestion-type {
            background: #f0f0f0;
            color: #666;
        }

        .suggestion-main:has(.autocomplete-suggestion-type:contains("sample")) .autocomplete-suggestion-type {
            background: #e8f5e8;
            color: #2d5016;
        }

        .suggestion-main:has(.autocomplete-suggestion-type:contains("event")) .autocomplete-suggestion-type {
            background: #fff3cd;
            color: #856404;
        }

        .suggestion-main:has(.autocomplete-suggestion-type:contains("keyword")) .autocomplete-suggestion-type {
            background: #d1ecf1;
            color: #0c5460;
        }

        .suggestion-main:has(.autocomplete-suggestion-type:contains("function")) .autocomplete-suggestion-type {
            background: #f8d7da;
            color: #721c24;
        }

        /* View query type styling */
        .suggestion-main:has(.autocomplete-suggestion-type:contains("view")) .autocomplete-suggestion-type {
            background: #e3f2fd;
            color: #1976d2;
        }

        .suggestion-main:has(.autocomplete-suggestion-type:contains("view-formatted")) .autocomplete-suggestion-type {
            background: #fff3e0;
            color: #f57c00;
        }

        .suggestion-main:has(.autocomplete-suggestion-type:contains("view-caption")) .autocomplete-suggestion-type {
            background: #f3e5f5;
            color: #7b1fa2;
        }
    </style>
</head>
<body>
<h1>JFR Query Tool <small>(experimental, <a
        href="https://github.com/parttimenerd/jfr-query-experiments">GitHub</a>)</small></h1>

<div class="controls-container">
    <div class="query-area">
        <select id="previousQueries" onchange="selectPreviousQuery()">
            <option value="">-- Select a previous or sample query --</option>
        </select>
        <div class="autocomplete-container">
            <textarea id="queryInput" placeholder="Enter your JFR query here..."></textarea>
            <div id="autocompleteSuggestions" class="autocomplete-suggestions"></div>
        </div>
    </div>
    <div class="buttons">
        <div class="auto-query">
            <input type="checkbox" id="autoQuery">
            <label for="autoQuery">Auto query</label>
        </div>
        <button id="executeButton" onclick="executeQuery(true)" title="Launch query, CTRL+Enter">Query</button>
    </div>
</div>

<div id="result">Results will appear here</div>

<script>
    let previousQueries = new Set();
    let autoQueryInterval = null;
    let lastExecutedQuery = "";
    let queryInput, highlightDiv;
    let autocompleteSuggestions;
    let currentSuggestions = [];
    let selectedSuggestionIndex = -1;

    // Add a cache for SHOW FIELDS results
    const showFieldsCache = new Map();

    // Centralized vocabulary definitions - single source of truth
    const queryVocabulary = {
        keywords: [
            'SELECT', 'FROM', 'WHERE', 'GROUP BY', 'ORDER BY', 'LIMIT',
            'COLUMN', 'CAPTION', 'FORMAT', 'AS', 'AND', 'ASC', 'DESC',
            'SHOW EVENTS', 'SHOW FIELDS'
        ],

        functions: [
            'AVG', 'COUNT', 'DIFF', 'FIRST', 'LAST', 'LAST_BATCH',
            'LIST', 'MAX', 'MEDIAN', 'MIN', 'P90', 'P95', 'P99', 'P999',
            'STDEV', 'SUM', 'UNIQUE'
        ],

        formatProperties: [
            'cell-height:', 'missing:whitespace', 'normalized',
            'truncate-beginning', 'truncate-end', 'missing:null-bootstrap'
        ],

        // Will be populated dynamically from SHOW EVENTS, fallback to common ones
        availableEventTypes: [
            'GarbageCollection', 'ExecutionSample', 'ObjectAllocationSample',
            'JavaMonitorEnter', 'JavaMonitorWait', 'ThreadPark', 'ThreadSleep',
            'SocketRead', 'SocketWrite', 'FileRead', 'FileWrite',
            'ClassLoad', 'Compilation', 'Deoptimization',
            'jdk.GarbageCollection', 'jdk.ExecutionSample', 'jdk.ObjectAllocationSample',
            'jdk.JavaMonitorEnter', 'jdk.ThreadPark', 'jdk.ClassLoad',
            'SystemProcess', 'CPULoad', 'GCHeapSummary', 'ActiveRecording'
        ],

        commonFields: [
            'startTime', 'duration', 'eventThread', 'stackTrace',
            'stackTrace.topFrame', 'stackTrace.topApplicationFrame',
            'eventType.label', 'gcId', 'objectClass', 'weight',
            'pid', 'path', 'bytesRead', 'bytesWritten', 'host'
        ],

        // Mix of strings and objects for sample queries
        sampleQueries: [
            // Simple command strings
            "grammar",
            "views",
            "SHOW EVENTS",
            "SHOW FIELDS jdk.GarbageCollection",

            // Simple query strings
            "SELECT * FROM GarbageCollection",
            "SELECT * FROM ExecutionSample",
            "SELECT * FROM ObjectAllocationSample",
            "SELECT startTime FROM GarbageCollection",
            "SELECT COUNT(*) FROM GarbageCollection",

            // Objects with descriptions
            {
                text: "SELECT stackTrace.topFrame AS T, SUM(weight) FROM ObjectAllocationSample GROUP BY T",
                type: 'sample',
                description: "Allocation pressure by method"
            },
            {
                text: "SELECT eventThread, COUNT(*) FROM ExecutionSample GROUP BY eventThread",
                type: 'sample',
                description: "Execution samples by thread"
            },
            {
                text: "SELECT gcId, duration FROM GarbageCollection ORDER BY duration DESC",
                type: 'sample',
                description: "GC events by duration"
            }
            // View queries will be added dynamically by loadViewQueries()
        ]
    };

    // Syntax highlighting functions using centralized vocabulary
    function createSyntaxHighlighter() {
        const originalQueryInput = document.getElementById('queryInput');
        const container = originalQueryInput.parentNode;

        const wrapper = document.createElement('div');
        wrapper.className = 'syntax-highlighter-wrapper';

        const highlightDiv = document.createElement('div');
        highlightDiv.id = 'highlightDiv';

        originalQueryInput.className = 'highlighted';

        container.replaceChild(wrapper, originalQueryInput);
        wrapper.appendChild(highlightDiv);
        wrapper.appendChild(originalQueryInput);

        return { queryInput: originalQueryInput, highlightDiv };
    }

    function highlightSyntax(text) {
        // Use centralized vocabulary
        const keywords = queryVocabulary.keywords;
        const functions = queryVocabulary.functions;

        text = text.replace(/[<>&]/g, function(match) {
            return {'<': '&lt;', '>': '&gt;', '&': '&amp;'}[match];
        });

        text = text.replace(/'([^']*)'/g, '<span class="sql-string">\'$1\'</span>');
        text = text.replace(/\b\d+\b/g, '<span class="sql-number">$&</span>');

        keywords.forEach(keyword => {
            const regex = new RegExp(`\\b${keyword.replace(/\s+/g, '\\s+')}\\b`, 'gi');
            text = text.replace(regex, '<span class="sql-keyword">$&</span>');
        });

        functions.forEach(func => {
            const regex = new RegExp(`\\b${func}\\b(?=\\s*\\()`, 'gi');
            text = text.replace(regex, '<span class="sql-function">$&</span>');
        });

        text = text.replace(/(?<!<[^>]*)\b=\b(?![^<]*>)/g, '<span class="sql-operator">=</span>');
        text = text.replace(/(?<!<[^>]*),(?![^<]*>)/g, '<span class="sql-operator">,</span>');
        text = text.replace(/(?<!<[^>]*)\((?![^<]*>)/g, '<span class="sql-operator">(</span>');
        text = text.replace(/(?<!<[^>]*)\)(?![^<]*>)/g, '<span class="sql-operator">)</span>');
        text = text.replace(/(?<!<[^>]*);(?![^<]*>)/g, '<span class="sql-operator">;</span>');

        return text;
    }

    function updateHighlighting() {
        if (highlightDiv && queryInput) {
            const text = queryInput.value;
            const highlighted = highlightSyntax(text);
            highlightDiv.innerHTML = highlighted;
        }
    }

    // Function to load available event types dynamically
    async function loadAvailableEventTypes() {
        try {
            const response = await fetch('/query?q=' + encodeURIComponent('SHOW EVENTS'));
            const data = await response.text();

            // Parse the SHOW EVENTS output to extract event types with counts
            const eventTypes = [];
            const eventCounts = {}; // Store counts for display
            const lines = data.split('\n');

            for (const line of lines) {
                // Match patterns like "ActiveRecording (1)" or "CPULoad (184)"
                const match = line.match(/^\s*([A-Za-z][A-Za-z0-9_]*)\s*\((\d+)\)/);
                if (match) {
                    const eventName = match[1];
                    const count = parseInt(match[2]);

                    // Only include events that have actual data (count > 0)
                    if (count > 0) {
                        eventTypes.push(eventName);
                        eventCounts[eventName] = count;
                    }
                }
            }

            // Update the vocabulary with actual available events and their counts
            if (eventTypes.length > 0) {
                queryVocabulary.availableEventTypes = eventTypes;
                queryVocabulary.eventCounts = eventCounts;
                console.log(`Loaded ${eventTypes.length} event types with data:`, eventTypes);
            }

        } catch (error) {
            console.warn('Could not load event types, using fallback list:', error);
            // Keep the fallback list that's already in availableEventTypes
        }
    }

    // Enhanced function to parse view.ini format and extract queries with descriptions
    function parseViewQueries(viewsData) {
        const viewQueries = [];
        const lines = viewsData.split('\n');
        let currentSection = null;
        let currentLabel = null;
        let inQuery = false;
        let queryLines = [];

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            // Skip comments and empty lines
            if (line.startsWith(';') || line === '') {
                continue;
            }

            // Section header like [environment.active-recordings]
            const sectionMatch = line.match(/^\[([^\]]+)\]$/);
            if (sectionMatch) {
                // Save previous query if exists
                if (currentSection && currentLabel && queryLines.length > 0) {
                    const fullQuery = queryLines.join(' ').trim();
                    if (fullQuery) {
                        const cleanQuery = extractCleanQuery(fullQuery);
                        viewQueries.push({
                            id: currentSection,
                            label: currentLabel,
                            fullQuery: fullQuery,
                            cleanQuery: cleanQuery,
                            category: currentSection.split('.')[0] // environment, application, jvm
                        });
                    }
                }

                currentSection = sectionMatch[1];
                currentLabel = null;
                queryLines = [];
                inQuery = false;
                continue;
            }

            // Label line
            const labelMatch = line.match(/^label\s*=\s*"([^"]+)"$/);
            if (labelMatch) {
                currentLabel = labelMatch[1];
                continue;
            }

            // Table or form query start
            const queryStartMatch = line.match(/^(table|form)\s*=\s*"(.*)$/);
            if (queryStartMatch) {
                inQuery = true;
                queryLines = [queryStartMatch[2]];
                continue;
            }

            // Continue multi-line query
            if (inQuery) {
                if (line.endsWith('"')) {
                    // End of query
                    queryLines.push(line.slice(0, -1));
                    inQuery = false;
                } else {
                    queryLines.push(line);
                }
            }
        }

        // Handle last query if file doesn't end with proper closure
        if (currentSection && currentLabel && queryLines.length > 0) {
            const fullQuery = queryLines.join(' ').trim();
            if (fullQuery) {
                const cleanQuery = extractCleanQuery(fullQuery);
                viewQueries.push({
                    id: currentSection,
                    label: currentLabel,
                    fullQuery: fullQuery,
                    cleanQuery: cleanQuery,
                    category: currentSection.split('.')[0]
                });
            }
        }

        return viewQueries;
    }

    // Function to extract clean query without COLUMN/FORMAT prefixes
    function extractCleanQuery(fullQuery) {
        // Remove COLUMN and FORMAT directives to get the core SQL
        let cleanQuery = fullQuery;

        // Remove COLUMN directive - handle multiline case
        cleanQuery = cleanQuery.replace(/^COLUMN\s+[^S]*?(SELECT)/i, '$1');

        // Remove FORMAT directive - handle multiline case
        cleanQuery = cleanQuery.replace(/FORMAT\s+[^S]*?(SELECT)/i, '$1');

        // Clean up extra whitespace
        cleanQuery = cleanQuery.replace(/\s+/g, ' ').trim();

        return cleanQuery;
    }

    // Function to create CAPTION version of a query
    function createCaptionQuery(viewQuery) {
        // Extract column names from COLUMN directive if present
        const columnMatch = viewQuery.fullQuery.match(/COLUMN\s+(.*?)\s+(?:FORMAT|SELECT)/is);
        if (columnMatch) {
            const columnDef = columnMatch[1].trim();
            // Create CAPTION version
            return `CAPTION ${columnDef} ${viewQuery.cleanQuery}`;
        }
        return null;
    }

    // Function to load view queries dynamically
    async function loadViewQueries() {
        try {
            const response = await fetch('/query?q=' + encodeURIComponent('views'));
            const data = await response.text();

            const viewQueries = parseViewQueries(data);

            if (viewQueries.length > 0) {
                console.log(`Loaded ${viewQueries.length} view queries`);

                // Add view queries to sample queries in multiple formats
                viewQueries.forEach(view => {
                    // Add the clean query (without COLUMN/FORMAT)
                    queryVocabulary.sampleQueries.push({
                        text: view.cleanQuery,
                        type: 'view',
                        description: view.label,
                        category: view.category,
                        id: view.id
                    });

                    // Add the full query (with COLUMN/FORMAT if present)
                    if (view.fullQuery !== view.cleanQuery) {
                        queryVocabulary.sampleQueries.push({
                            text: view.fullQuery,
                            type: 'view-formatted',
                            description: `${view.label} (formatted)`,
                            category: view.category,
                            id: view.id
                        });
                    }

                    // Add CAPTION version if COLUMN directive exists
                    const captionQuery = createCaptionQuery(view);
                    if (captionQuery) {
                        queryVocabulary.sampleQueries.push({
                            text: captionQuery,
                            type: 'view-caption',
                            description: `${view.label} (caption)`,
                            category: view.category,
                            id: view.id
                        });
                    }
                });

                console.log(`Added ${queryVocabulary.sampleQueries.filter(s => s.type?.startsWith('view')).length} view-based sample queries`);
            }

        } catch (error) {
            console.warn('Could not load view queries:', error);
        }
    }

    // Enhanced function to check for and execute SHOW FIELDS suggestions
    async function checkAndExecuteShowFields(errorMessage) {
        // Look for patterns like "SHOW FIELDS SomeEventName" in the error message
        const showFieldsMatch = errorMessage.match(/SHOW FIELDS\s+([A-Za-z][A-Za-z0-9_.]*)/);

        if (showFieldsMatch) {
            const eventName = showFieldsMatch[1];
            const showFieldsQuery = `SHOW FIELDS ${eventName}`;

            // Check cache first
            if (showFieldsCache.has(showFieldsQuery)) {
                console.log(`Using cached fields for: ${eventName}`);
                displayShowFieldsResult(showFieldsQuery, showFieldsCache.get(showFieldsQuery));
                return;
            }

            try {
                console.log(`Auto-executing: ${showFieldsQuery}`);
                const response = await fetch(`/query?q=${encodeURIComponent(showFieldsQuery)}`);
                const fieldsData = await response.text();

                // Use the enhanced cache function
                addToShowFieldsCache(showFieldsQuery, fieldsData);
                console.log(`Cached fields for: ${eventName}`);

                // Display the fields information
                displayShowFieldsResult(showFieldsQuery, fieldsData);

            } catch (error) {
                console.warn('Failed to auto-execute SHOW FIELDS:', error);
                const resultDiv = document.getElementById('result');
                const currentContent = resultDiv.textContent;
                resultDiv.textContent = currentContent + `\n\nFailed to auto-execute: ${showFieldsQuery}`;
            }
        }
    }

    // Function to display SHOW FIELDS results below the error message
    function displayShowFieldsResult(query, fieldsData) {
        const resultDiv = document.getElementById('result');
        const currentContent = resultDiv.textContent;

        // Create a separator and add the fields information
        const separator = '\n\n' + '='.repeat(50) + '\n';
        const fieldsSection = `Auto-executed: ${query}\n${separator}${fieldsData}`;

        resultDiv.textContent = currentContent + '\n\n' + fieldsSection;

        // Scroll to show the new content
        resultDiv.scrollTop = resultDiv.scrollHeight;
    }

    // Enhanced cache management - add function to get cache statistics
    function getShowFieldsCacheStats() {
        console.log(`SHOW FIELDS cache contains ${showFieldsCache.size} entries:`);
        for (const [query, data] of showFieldsCache.entries()) {
            console.log(`- ${query}: ${data.length} characters`);
        }
    }

    // Enhanced cache clear function with statistics
    function clearShowFieldsCache() {
        const size = showFieldsCache.size;
        showFieldsCache.clear();
        console.log(`SHOW FIELDS cache cleared (${size} entries removed)`);
    }

    // Optional: Add cache size limit to prevent memory issues
    const MAX_CACHE_SIZE = 50; // Maximum number of cached SHOW FIELDS results

    function addToShowFieldsCache(query, data) {
        // If cache is at limit, remove oldest entry (simple LRU)
        if (showFieldsCache.size >= MAX_CACHE_SIZE) {
            const firstKey = showFieldsCache.keys().next().value;
            showFieldsCache.delete(firstKey);
            console.log(`Cache limit reached, removed: ${firstKey}`);
        }

        showFieldsCache.set(query, data);
    }

    // Initialize sample queries - only add strings to previousQueries Set
    queryVocabulary.sampleQueries.forEach(query => {
        // Only add string queries to the dropdown, skip objects
        if (typeof query === 'string') {
            previousQueries.add(query);
        } else {
            // For object queries, add just the text part
            previousQueries.add(query.text);
        }
    });

    // Enhanced function to add sample query suggestions
    function addSampleQuerySuggestions(suggestions, currentWord) {
        queryVocabulary.sampleQueries.forEach(query => {
            // Handle both string and object formats
            const queryText = typeof query === 'string' ? query : query.text;
            const queryType = typeof query === 'string' ? 'sample' : (query.type || 'sample');
            const queryDescription = typeof query === 'string' ? '' : (query.description || '');

            if (currentWord.length === 0 ||
                queryText.toLowerCase().includes(currentWord.toLowerCase())) {

                let description = queryDescription;
                if (!description && typeof query === 'string') {
                    // Generate description for string queries
                    if (queryText.includes('SHOW')) {
                        description = 'Show information';
                    } else if (queryText.includes('CAPTION')) {
                        description = 'Formatted report';
                    } else if (queryText.includes('SELECT') && queryText.includes('GROUP BY')) {
                        description = 'Aggregation query';
                    } else if (queryText.includes('SELECT')) {
                        description = 'Basic query';
                    } else if (queryText === 'grammar' || queryText === 'views') {
                        description = 'Help command';
                    }
                }

                suggestions.push({
                    text: queryText,
                    type: queryType,
                    description: description
                });
            }
        });
    }

    // Enhanced auto-completion function with better sample query logic
    function getAutoCompleteSuggestions(text, cursorPos) {
        const beforeCursor = text.substring(0, cursorPos);
        const wordMatch = beforeCursor.match(/\b\w*$/);
        const currentWord = wordMatch ? wordMatch[0].toLowerCase() : '';

        const suggestions = [];
        const context = getQueryContext(beforeCursor);

        // Add sample queries when at the start or for short inputs
        if (beforeCursor.trim().length < 10 || context === 'start') {
            addSampleQuerySuggestions(suggestions, currentWord);
        }

        // Add context-specific suggestions
        switch (context) {
            case 'start':
            case 'after_keyword':
                addSuggestions(suggestions, queryVocabulary.keywords, currentWord, 'keyword');
                break;
            case 'after_select':
                addSuggestions(suggestions, queryVocabulary.functions, currentWord, 'function');
                addSuggestions(suggestions, queryVocabulary.commonFields, currentWord, 'field');
                break;
            case 'after_from':
                addEventSuggestions(suggestions, queryVocabulary.availableEventTypes, currentWord);
                break;
            case 'after_format':
                addSuggestions(suggestions, queryVocabulary.formatProperties, currentWord, 'property');
                break;
            default:
                addSuggestions(suggestions, queryVocabulary.keywords, currentWord, 'keyword');
                addSuggestions(suggestions, queryVocabulary.functions, currentWord, 'function');
                addSuggestions(suggestions, queryVocabulary.commonFields, currentWord, 'field');
                addEventSuggestions(suggestions, queryVocabulary.availableEventTypes, currentWord);
        }

        // Sort suggestions - DON'T prioritize view queries, keep them mixed in
        suggestions.sort((a, b) => {
            const trimmedInput = beforeCursor.trim().toLowerCase();

            // Prioritize exact matches from the beginning
            const aStartsWithInput = a.text.toLowerCase().startsWith(trimmedInput);
            const bStartsWithInput = b.text.toLowerCase().startsWith(trimmedInput);

            if (aStartsWithInput && !bStartsWithInput) return -1;
            if (!aStartsWithInput && bStartsWithInput) return 1;

            // Otherwise keep original order (mixed)
            return 0;
        });

        return suggestions.slice(0, 20);
    }

    // New function to add event suggestions with counts
    function addEventSuggestions(suggestions, eventTypes, currentWord) {
        eventTypes.forEach(eventType => {
            if (eventType.toLowerCase().includes(currentWord.toLowerCase()) ||
                eventType.toLowerCase().startsWith(currentWord.toLowerCase())) {
                const count = queryVocabulary.eventCounts && queryVocabulary.eventCounts[eventType]
                    ? queryVocabulary.eventCounts[eventType]
                    : '';

                suggestions.push({
                    text: eventType,
                    type: 'event',
                    count: count,
                    description: count ? `${count} events` : ''
                });
            }
        });
    }

    // Enhanced suggestion display to show counts and descriptions
    function showAutoCompleteSuggestions(suggestions) {
        if (suggestions.length === 0) {
            hideAutoCompleteSuggestions();
            return;
        }

        currentSuggestions = suggestions;
        selectedSuggestionIndex = -1; // Don't preselect any suggestion

        const html = suggestions.map((suggestion, index) => {
            let displayText = suggestion.text;
            let metaInfo = '';

            // Format based on suggestion type
            if (suggestion.type === 'event' && suggestion.count) {
                metaInfo = `<span class="suggestion-count">${suggestion.count} events</span>`;
            } else if (suggestion.description) {
                metaInfo = `<span class="suggestion-description">${suggestion.description}</span>`;
            }

            // Truncate very long queries for display
            if ((suggestion.type?.startsWith('view') || suggestion.type === 'sample') && displayText.length > 80) {
                displayText = displayText.substring(0, 80) + '...';
            }

            return `<div class="autocomplete-suggestion" data-index="${index}">
                <div class="suggestion-main">
                    <div class="suggestion-text">${displayText}</div>
                    <div class="suggestion-meta">
                        <span class="autocomplete-suggestion-type">${suggestion.type}</span>
                        ${metaInfo}
                    </div>
                </div>
            </div>`;
        }).join('');

        autocompleteSuggestions.innerHTML = html;
        autocompleteSuggestions.style.display = 'block';

        // Add click handlers
        autocompleteSuggestions.querySelectorAll('.autocomplete-suggestion').forEach(elem => {
            elem.addEventListener('click', () => {
                applySuggestion(suggestions[parseInt(elem.dataset.index)]);
            });
        });
    }

    // Enhanced applySuggestion to handle sample queries better
    function applySuggestion(suggestion) {
        const cursorPos = queryInput.selectionStart;
        const text = queryInput.value;
        const beforeCursor = text.substring(0, cursorPos);
        const afterCursor = text.substring(cursorPos);

        let newText, newPos;

        // For sample queries, replace the entire query if we're at the start
        if (suggestion.type === 'sample' && beforeCursor.trim().length < 10) {
            newText = suggestion.text;
            newPos = suggestion.text.length;
        } else {
            // For other suggestions, find the current partial word
            const wordMatch = beforeCursor.match(/\b\w*$/);
            const wordStart = wordMatch ? cursorPos - wordMatch[0].length : cursorPos;

            // Replace the partial word with the suggestion
            newText = text.substring(0, wordStart) + suggestion.text + afterCursor;
            newPos = wordStart + suggestion.text.length;
        }

        queryInput.value = newText;
        queryInput.setSelectionRange(newPos, newPos);

        hideAutoCompleteSuggestions();
        updateHighlighting();
        queryInput.focus();
    }

    function getQueryContext(beforeCursor) {
        const trimmed = beforeCursor.trim().toLowerCase();

        if (trimmed === '' || /^\s*$/.test(trimmed)) return 'start';
        if (/\bselect\s*$/i.test(trimmed)) return 'after_select';
        if (/\bfrom\s*$/i.test(trimmed)) return 'after_from';
        if (/\bformat\s*$/i.test(trimmed)) return 'after_format';
        if (/\bwhere\s*$/i.test(trimmed)) return 'after_where';
        if (/\bgroup\s+by\s*$/i.test(trimmed)) return 'after_group_by';
        if (/\border\s+by\s*$/i.test(trimmed)) return 'after_order_by';

        return 'general';
    }

    function addSuggestions(suggestions, items, currentWord, type) {
        items.forEach(item => {
            if (item.toLowerCase().startsWith(currentWord)) {
                suggestions.push({ text: item, type: type });
            }
        });
    }

    function hideAutoCompleteSuggestions() {
        autocompleteSuggestions.style.display = 'none';
        currentSuggestions = [];
        selectedSuggestionIndex = -1;
    }

    // Update navigateSuggestions to handle the case where no suggestion is initially selected
    function navigateSuggestions(direction) {
        if (currentSuggestions.length === 0) return;

        // Remove previous selection
        if (selectedSuggestionIndex >= 0) {
            const prevSelected = autocompleteSuggestions.children[selectedSuggestionIndex];
            if (prevSelected) {
                prevSelected.classList.remove('selected');
            }
        }

        // Update selection
        if (selectedSuggestionIndex === -1) {
            // If no selection, start from first (down) or last (up)
            selectedSuggestionIndex = direction > 0 ? 0 : currentSuggestions.length - 1;
        } else {
            selectedSuggestionIndex += direction;
            if (selectedSuggestionIndex < 0) {
                selectedSuggestionIndex = currentSuggestions.length - 1;
            } else if (selectedSuggestionIndex >= currentSuggestions.length) {
                selectedSuggestionIndex = 0;
            }
        }

        // Add new selection
        const newSelected = autocompleteSuggestions.children[selectedSuggestionIndex];
        if (newSelected) {
            newSelected.classList.add('selected');
            newSelected.scrollIntoView({ block: 'nearest' });
        }
    }

    function updatePreviousQueriesDropdown() {
        const select = document.getElementById('previousQueries');

        while (select.options.length > 1) {
            select.remove(1);
        }

        const specialOptions = ["grammar", "views"];
        specialOptions.forEach(query => {
            if (!previousQueries.has(query)) {
                const option = document.createElement('option');
                option.value = query;
                option.text = query;
                select.add(option);
            }
        });

        Array.from(previousQueries).sort((a, b) => {
            // Handle both string and object queries for sorting
            const aText = typeof a === 'string' ? a : a.text;
            const bText = typeof b === 'string' ? b : b.text;
            return aText.localeCompare(bText);
        }).forEach(query => {
            const option = document.createElement('option');

            // Handle both string and object queries
            const queryText = typeof query === 'string' ? query : query.text;
            const queryDescription = typeof query === 'string' ? '' : query.description;

            option.value = queryText;

            // Create display text with description if available
            let displayText = queryText.length > 50 ? queryText.substring(0, 50) + '...' : queryText;
            if (queryDescription) {
                displayText += ` (${queryDescription})`;
            }

            option.text = displayText;
            select.add(option);
        });
    }

    // Enhanced executeQuery function with SHOW FIELDS auto-execution and syntax highlighting
    function executeQuery(addToHistory = false) {
        const query = queryInput.value;
        if (!query) return;

        // Hide autocompletion when executing query
        hideAutoCompleteSuggestions();

        // Skip if this exact query was just executed
        if (query === lastExecutedQuery) return;

        lastExecutedQuery = query;

        // Only add to history if explicitly requested (via button click)
        if (addToHistory && !previousQueries.has(query)) {
            previousQueries.add(query);
            updatePreviousQueriesDropdown();
        }

        document.getElementById('result').textContent = 'Executing query...';

        fetch(`/query?q=${encodeURIComponent(query)}`)
            .then(response => response.text())
            .then(data => {
                const resultDiv = document.getElementById('result');
                
                // Apply syntax highlighting if this is a views query
                if (query.trim().toLowerCase() === 'views') {
                    resultDiv.innerHTML = highlightViewsOutput(data);
                } else {
                    resultDiv.textContent = data;
                }

                // Check if the error message contains a SHOW FIELDS suggestion
                checkAndExecuteShowFields(data);

                // If this was a SHOW EVENTS query, refresh our event types
                if (query.trim().toUpperCase() === 'SHOW EVENTS') {
                    setTimeout(loadAvailableEventTypes, 100);
                }
            })
            .catch(error => {
                document.getElementById('result').textContent = 'Error: ' + error;
            });
    }

    // Function to highlight the views output with syntax highlighting
    function highlightViewsOutput(viewsData) {
        const lines = viewsData.split('\n');
        const highlightedLines = [];
        let inQuery = false;
        let queryLines = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // Check if this is a section header
            if (line.match(/^\[([^\]]+)\]$/)) {
                // If we were in a query, highlight it first
                if (inQuery && queryLines.length > 0) {
                    const queryText = queryLines.join('\n');
                    const highlighted = highlightSyntax(queryText);
                    highlightedLines.push(highlighted);
                    queryLines = [];
                    inQuery = false;
                }
                
                // Add the section header with special styling
                highlightedLines.push(`<span class="view-section">${escapeHtml(line)}</span>`);
                continue;
            }
            
            // Check if this is a label line
            if (line.match(/^label\s*=\s*"([^"]+)"$/)) {
                highlightedLines.push(`<span class="view-label">${escapeHtml(line)}</span>`);
                continue;
            }
            
            // Check if this starts a query
            if (line.match(/^(table|form)\s*=\s*"/)) {
                inQuery = true;
                queryLines = [line];
                continue;
            }
            
            // If we're in a query, collect lines
            if (inQuery) {
                queryLines.push(line);
                
                // Check if this ends the query
                if (line.trim().endsWith('"')) {
                    // Highlight the complete query
                    const queryText = queryLines.join('\n');
                    const highlighted = highlightViewsQuery(queryText);
                    highlightedLines.push(highlighted);
                    queryLines = [];
                    inQuery = false;
                }
                continue;
            }
            
            // For other lines (comments, etc.), just escape and add
            if (line.trim().startsWith(';')) {
                highlightedLines.push(`<span class="view-comment">${escapeHtml(line)}</span>`);
            } else if (line.trim() === '') {
                highlightedLines.push('');
            } else {
                highlightedLines.push(escapeHtml(line));
            }
        }
        
        // Handle any remaining query at the end
        if (inQuery && queryLines.length > 0) {
            const queryText = queryLines.join('\n');
            const highlighted = highlightViewsQuery(queryText);
            highlightedLines.push(highlighted);
        }
        
        return highlightedLines.join('\n');
    }

    // Function to highlight a query within the views output
    function highlightViewsQuery(queryText) {
        // Extract the SQL part from the query definition
        let sqlPart = queryText;
        
        // Split into lines to handle the structure
        const lines = queryText.split('\n');
        const highlightedLines = [];
        
        for (const line of lines) {
            if (line.match(/^(table|form)\s*=\s*"/)) {
                // This is the start line
                const match = line.match(/^((table|form)\s*=\s*")(.*)/);
                if (match) {
                    const prefix = match[1];
                    const sqlStart = match[3];
                    highlightedLines.push(
                        `<span class="view-query-type">${escapeHtml(prefix)}</span>` +
                        (sqlStart ? highlightSyntax(sqlStart) : '')
                    );
                } else {
                    highlightedLines.push(escapeHtml(line));
                }
            } else if (line.trim().endsWith('"')) {
                // This is the end line
                const sqlEnd = line.substring(0, line.lastIndexOf('"'));
                const quote = '"';
                highlightedLines.push(
                    (sqlEnd ? highlightSyntax(sqlEnd) : '') +
                    `<span class="view-query-type">${escapeHtml(quote)}</span>`
                );
            } else {
                // This is a middle line with SQL content
                if (line.trim()) {
                    highlightedLines.push(highlightSyntax(line));
                } else {
                    highlightedLines.push(line);
                }
            }
        }
        
        return highlightedLines.join('\n');
    }

    // Helper function to escape HTML
    function escapeHtml(text) {
        return text.replace(/[<>&"']/g, function(match) {
            return {
                '<': '&lt;',
                '>': '&gt;',
                '&': '&amp;',
                '"': '&quot;',
                "'": '&#39;'
            }[match];
        });
    }

    // Function for selecting previous queries from dropdown
    function selectPreviousQuery() {
        const select = document.getElementById('previousQueries');
        const query = select.value;
        if (query) {
            queryInput.value = query;
            select.selectedIndex = 0;
            updateHighlighting(); // Trigger highlighting update

            if (document.getElementById('autoQuery').checked) {
                executeQuery(false);
            }
        }
    }

    // Auto-query functionality
    function checkAndExecuteQuery() {
        const query = queryInput.value;
        if (query && query !== lastExecutedQuery) {
            // Don't add to history during auto-query
            executeQuery(false);
        }
    }

    // Handle auto-query checkbox
    document.getElementById('autoQuery').addEventListener('change', function() {
        if (this.checked) {
            autoQueryInterval = setInterval(checkAndExecuteQuery, 1000);
        } else {
            if (autoQueryInterval) {
                clearInterval(autoQueryInterval);
                autoQueryInterval = null;
            }
        }
    });

    // Hide suggestions when clicking outside
    document.addEventListener('click', function(e) {
        if (!e.target.closest('.autocomplete-container')) {
            hideAutoCompleteSuggestions();
        }
    });

    // Load event types and view queries when the page loads
    window.addEventListener('load', function() {
        loadAvailableEventTypes();
        loadViewQueries();
    });

    // Initialize everything
    updatePreviousQueriesDropdown();

    // Initialize syntax highlighter
    const highlighterElements = createSyntaxHighlighter();
    queryInput = highlighterElements.queryInput;
    highlightDiv = highlighterElements.highlightDiv;
    autocompleteSuggestions = document.getElementById('autocompleteSuggestions');

    // Event listeners
    queryInput.addEventListener('input', function(e) {
        updateHighlighting();

        const suggestions = getAutoCompleteSuggestions(queryInput.value, queryInput.selectionStart);
        showAutoCompleteSuggestions(suggestions);
    });

    queryInput.addEventListener('scroll', function() {
        highlightDiv.scrollTop = queryInput.scrollTop;
        highlightDiv.scrollLeft = queryInput.scrollLeft;
    });

    queryInput.addEventListener('keydown', function(e) {
        if (autocompleteSuggestions && autocompleteSuggestions.style.display === 'block') {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                navigateSuggestions(1);
                return;
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                navigateSuggestions(-1);
                return;
            } else if (e.key === 'Tab') {
                e.preventDefault();
                if (currentSuggestions.length > 0) {
                    if (selectedSuggestionIndex === -1) {
                        // If no suggestion is selected, select the first one
                        selectedSuggestionIndex = 0;
                        const firstSuggestion = autocompleteSuggestions.children[0];
                        if (firstSuggestion) {
                            firstSuggestion.classList.add('selected');
                        }
                    } else {
                        // Tab cycles forward, Shift+Tab cycles backward
                        navigateSuggestions(e.shiftKey ? -1 : 1);
                    }
                }
                return;
            } else if (e.key === 'Enter' && selectedSuggestionIndex >= 0) {
                e.preventDefault();
                applySuggestion(currentSuggestions[selectedSuggestionIndex]);
                return;
            } else if (e.key === 'Escape') {
                hideAutoCompleteSuggestions();
                return;
            }
        }

        if ((e.key === 'Enter' || e.keyCode === 13) && (e.ctrlKey || e.metaKey)) {
            console.log('Ctrl+Enter pressed, executing query...');
            // Hide autocompletion before executing
            hideAutoCompleteSuggestions();
            executeQuery(true);
            e.preventDefault();
            return false;
        }
    });

    // Initial highlighting
    updateHighlighting();
</script>
</body>
</html>