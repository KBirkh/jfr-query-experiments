<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>JFR Query Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            padding-top: 0;
            padding-bottom: 0;
        }
        .controls-container {
            display: flex;
            margin-bottom: 10px;
            gap: 10px;
        }
        .query-area {
            flex-grow: 1;
        }
        #queryInput {
            width: 100%;
            font-family: monospace;
            padding: 8px;
            box-sizing: border-box;
            height: 100px;
        }
        #previousQueries {
            width: 100%;
            margin-bottom: 5px;
            padding: 5px;
        }
        .buttons {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            gap: 5px;
        }
        #executeButton {
            padding: 8px 15px;
        }
        .auto-query {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #result {
            font-family: monospace;
            white-space: pre-wrap;
            overflow-y: auto;
            height: calc(100vh - 250px);
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f5f5f5;
            line-height: 1.4;
            position: relative; /* Ensure proper stacking context for sticky headers */
        }

        /* Syntax highlighting styles */
        .syntax-highlighter-wrapper {
            position: relative;
            width: 100%;
            height: 100px;
        }

        #highlightDiv {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            font-family: monospace;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            background-color: white;
            white-space: pre-wrap;
            overflow: hidden;
            pointer-events: none;
            z-index: 1;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        #queryInput.highlighted {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            font-family: monospace;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            background-color: transparent;
            color: transparent;
            caret-color: black;
            resize: none;
            z-index: 2;
        }

        .sql-keyword { color: #0066cc; font-weight: bold; }
        .sql-function { color: #cc6600; font-weight: bold; }
        .sql-string { color: #009900; }
        .sql-field { color: #660066; }
        .sql-operator { color: #cc0000; }
        .sql-number { color: #ff6600; }
        .sql-comment { color: #999999; font-style: italic; }

        .view-section {
            color: #0066cc;
            font-weight: bold;
            background-color: #f0f8ff;
            padding: 2px 4px;
            border-left: 3px solid #0066cc;
        }

        .view-label {
            color: #006600;
            font-weight: bold;
        }

        .view-comment {
            color: #999999;
            font-style: italic;
        }

        .view-query-type {
            color: #666666;
            font-weight: bold;
        }

        /* Enhanced result div to support HTML content */
        #result {
            font-family: monospace;
            white-space: pre-wrap;
            overflow-y: auto;
            height: calc(100vh - 250px);
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f5f5f5;
            line-height: 1.4;
            position: relative; /* Ensure proper stacking context for sticky headers */
        }

        /* Auto-completion styles */
        .autocomplete-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ccc;
            border-top: none;
            max-height: 300px; /* Increased for more suggestions */
            overflow-y: auto;
            z-index: 1000;
            display: none;
            font-size: 13px;
        }

        .autocomplete-suggestion {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.selected {
            background-color: #e6f3ff;
        }

        .suggestion-main {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px;
        }

        .suggestion-text {
            font-family: monospace;
            font-weight: 500;
            color: #333;
            flex: 1;
            word-break: break-all;
        }

        .suggestion-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
            flex-shrink: 0;
        }

        .autocomplete-suggestion-type {
            font-size: 0.75em;
            color: #666;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            text-transform: uppercase;
            font-weight: bold;
        }

        .suggestion-count {
            font-size: 0.7em;
            color: #007acc;
            font-weight: bold;
            background: #e8f4fd;
            padding: 1px 4px;
            border-radius: 2px;
        }

        .suggestion-description {
            font-size: 0.7em;
            color: #888;
            font-style: italic;
            text-align: right;
            max-width: 120px;
            word-wrap: break-word;
        }

        /* Color coding for different suggestion types */
        .autocomplete-suggestion-type {
            background: #f0f0f0;
            color: #666;
        }

        .suggestion-main:has(.autocomplete-suggestion-type:contains("sample")) .autocomplete-suggestion-type {
            background: #e8f5e8;
            color: #2d5016;
        }

        .suggestion-main:has(.autocomplete-suggestion-type:contains("event")) .autocomplete-suggestion-type {
            background: #fff3cd;
            color: #856404;
        }

        .suggestion-main:has(.autocomplete-suggestion-type:contains("keyword")) .autocomplete-suggestion-type {
            background: #d1ecf1;
            color: #0c5460;
        }

        .suggestion-main:has(.autocomplete-suggestion-type:contains("function")) .autocomplete-suggestion-type {
            background: #f8d7da;
            color: #721c24;
        }

        /* View query type styling */
        .suggestion-main:has(.autocomplete-suggestion-type:contains("view")) .autocomplete-suggestion-type {
            background: #e3f2fd;
            color: #1976d2;
        }

        .suggestion-main:has(.autocomplete-suggestion-type:contains("view-formatted")) .autocomplete-suggestion-type {
            background: #fff3e0;
            color: #f57c00;
        }

        .suggestion-main:has(.autocomplete-suggestion-type:contains("view-caption")) .autocomplete-suggestion-type {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        /* JFR Table Styles - Fixed sticky header */
        .jfr-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-family: monospace;
            font-size: 13px;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .jfr-table th {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 8px 12px;
            text-align: left;
            font-weight: bold;
            color: #495057;
            position: sticky;
            top: -1px; /* Fix for the gap - offset by border width */
            z-index: 10;
            box-shadow: 0 1px 0 0 #dee2e6; /* Add bottom border shadow to maintain separation */
        }

        .jfr-table td {
            border: 1px solid #dee2e6;
            padding: 6px 12px;
            vertical-align: top;
        }

        .jfr-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        .jfr-table tr:hover {
            background-color: #e9ecef;
        }

        /* Handle long content in cells */
        .jfr-table td {
            max-width: 200px;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Make the result container scrollable for tables */
        #result:has(.jfr-table) {
            overflow: auto;
        }

        /* SHOW EVENTS specific styling */
        .show-events-summary {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            border-left: 4px solid #007acc;
        }

        .show-events-table .has-data {
            background-color: #d4edda;
        }

        .show-events-table .no-data {
            background-color: #f8d7da;
            opacity: 0.7;
        }

        .show-events-table .has-data:hover {
            background-color: #c3e6cb;
        }

        .show-events-table .no-data:hover {
            background-color: #f1b5ba;
        }

        /* Enhanced sortable table styles */
        .sortable-table th[data-sort] {
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.2s ease;
        }

        .sortable-table th[data-sort]:hover {
            background-color: #e9ecef;
        }

        .sort-indicator {
            font-size: 0.8em;
            color: #666;
            margin-left: 5px;
            font-weight: normal;
        }

        .sortable-table th.sort-asc,
        .sortable-table th.sort-desc {
            background-color: #e3f2fd;
        }

        .sortable-table th.sort-asc .sort-indicator,
        .sortable-table th.sort-desc .sort-indicator {
            color: #1976d2;
            font-weight: bold;
        }
    </style>
</head>
<body>
<h1>JFR Query Tool <small>(experimental, <a
        href="https://github.com/parttimenerd/jfr-query-experiments">GitHub</a>)</small></h1>

<div class="controls-container">
    <div class="query-area">
        <select id="previousQueries" onchange="selectPreviousQuery()">
            <option value="">-- Select a previous or sample query --</option>
        </select>
        <div class="autocomplete-container">
            <textarea id="queryInput" placeholder="Enter your JFR query here..."></textarea>
            <div id="autocompleteSuggestions" class="autocomplete-suggestions"></div>
        </div>
    </div>
    <div class="buttons">
        <div class="auto-query">
            <input type="checkbox" id="autoQuery">
            <label for="autoQuery">Auto query</label>
        </div>
        <div class="auto-query">
            <input type="checkbox" id="formatTables" checked>
            <label for="formatTables">Format output</label>
        </div>
        <button id="executeButton" onclick="executeQuery(true)" title="Launch query, CTRL+Enter">Query</button>
    </div>
</div>

<div id="result">Results will appear here</div>

<script>
    let previousQueries = new Set();
    let autoQueryInterval = null;
    let lastExecutedQuery = "";
    let queryInput, highlightDiv;
    let autocompleteSuggestions;
    let currentSuggestions = [];
    let selectedSuggestionIndex = -1;

    // Add a cache for SHOW FIELDS results
    const showFieldsCache = new Map();

    // Centralized vocabulary definitions - single source of truth
    const queryVocabulary = {
        keywords: [
            'SELECT', 'FROM', 'WHERE', 'GROUP BY', 'ORDER BY', 'LIMIT',
            'COLUMN', 'CAPTION', 'FORMAT', 'AS', 'AND', 'ASC', 'DESC',
            'SHOW EVENTS', 'SHOW FIELDS'
        ],

        functions: [
            'AVG', 'COUNT', 'DIFF', 'FIRST', 'LAST', 'LAST_BATCH',
            'LIST', 'MAX', 'MEDIAN', 'MIN', 'P90', 'P95', 'P99', 'P999',
            'STDEV', 'SUM', 'UNIQUE'
        ],

        formatProperties: [
            'cell-height:', 'missing:whitespace', 'normalized',
            'truncate-beginning', 'truncate-end', 'missing:null-bootstrap'
        ],

        // Will be populated dynamically from SHOW EVENTS, fallback to common ones
        availableEventTypes: [
            'GarbageCollection', 'ExecutionSample', 'ObjectAllocationSample',
            'JavaMonitorEnter', 'JavaMonitorWait', 'ThreadPark', 'ThreadSleep',
            'SocketRead', 'SocketWrite', 'FileRead', 'FileWrite',
            'ClassLoad', 'Compilation', 'Deoptimization',
            'jdk.GarbageCollection', 'jdk.ExecutionSample', 'jdk.ObjectAllocationSample',
            'jdk.JavaMonitorEnter', 'jdk.ThreadPark', 'jdk.ClassLoad',
            'SystemProcess', 'CPULoad', 'GCHeapSummary', 'ActiveRecording'
        ],

        commonFields: [
            'startTime', 'duration', 'eventThread', 'stackTrace',
            'stackTrace.topFrame', 'stackTrace.topApplicationFrame',
            'eventType.label', 'gcId', 'objectClass', 'weight',
            'pid', 'path', 'bytesRead', 'bytesWritten', 'host'
        ],

        // Mix of strings and objects for sample queries
        sampleQueries: [
            // Simple command strings
            "grammar",
            "views",
            "SHOW EVENTS",
            "SHOW FIELDS jdk.GarbageCollection",

            // Simple query strings
            "SELECT * FROM GarbageCollection",
            "SELECT * FROM ExecutionSample",
            "SELECT * FROM ObjectAllocationSample",
            "SELECT startTime FROM GarbageCollection",
            "SELECT COUNT(*) FROM GarbageCollection",

            // Objects with descriptions
            {
                text: "SELECT stackTrace.topFrame AS T, SUM(weight) FROM ObjectAllocationSample GROUP BY T",
                type: 'sample',
                description: "Allocation pressure by method"
            },
            {
                text: "SELECT gcId, duration FROM GarbageCollection ORDER BY duration DESC",
                type: 'sample',
                description: "GC events by duration"
            }
            // View queries will be added dynamically by loadViewQueries()
        ]
    };

    // Syntax highlighting functions using centralized vocabulary
    function createSyntaxHighlighter() {
        const originalQueryInput = document.getElementById('queryInput');
        const container = originalQueryInput.parentNode;

        const wrapper = document.createElement('div');
        wrapper.className = 'syntax-highlighter-wrapper';

        const highlightDiv = document.createElement('div');
        highlightDiv.id = 'highlightDiv';

        originalQueryInput.className = 'highlighted';

        container.replaceChild(wrapper, originalQueryInput);
        wrapper.appendChild(highlightDiv);
        wrapper.appendChild(originalQueryInput);

        return { queryInput: originalQueryInput, highlightDiv };
    }

    function highlightSyntax(text) {
        // Use centralized vocabulary
        const keywords = queryVocabulary.keywords;
        const functions = queryVocabulary.functions;

        text = text.replace(/[<>&]/g, function(match) {
            return {'<': '&lt;', '>': '&gt;', '&': '&amp;'}[match];
        });

        text = text.replace(/'([^']*)'/g, '<span class="sql-string">\'$1\'</span>');
        text = text.replace(/\b\d+\b/g, '<span class="sql-number">$&</span>');

        keywords.forEach(keyword => {
            const regex = new RegExp(`\\b${keyword.replace(/\s+/g, '\\s+')}\\b`, 'gi');
            text = text.replace(regex, '<span class="sql-keyword">$&</span>');
        });

        functions.forEach(func => {
            const regex = new RegExp(`\\b${func}\\b(?=\\s*\\()`, 'gi');
            text = text.replace(regex, '<span class="sql-function">$&</span>');
        });

        text = text.replace(/(?<!<[^>]*)\b=\b(?![^<]*>)/g, '<span class="sql-operator">=</span>');
        text = text.replace(/(?<!<[^>]*),(?![^<]*>)/g, '<span class="sql-operator">,</span>');
        text = text.replace(/(?<!<[^>]*)\((?![^<]*>)/g, '<span class="sql-operator">(</span>');
        text = text.replace(/(?<!<[^>]*)\)(?![^<]*>)/g, '<span class="sql-operator">)</span>');
        text = text.replace(/(?<!<[^>]*);(?![^<]*>)/g, '<span class="sql-operator">;</span>');

        return text;
    }

    function updateHighlighting() {
        if (highlightDiv && queryInput) {
            const text = queryInput.value;
            const highlighted = highlightSyntax(text);
            highlightDiv.innerHTML = highlighted;
        }
    }

    // Function to detect if output is tabular data
    function isTabularData(data) {
        const lines = data.split('\n');
        if (lines.length < 3) return false;

        // Look for a header separator line with dashes
        for (let i = 1; i < Math.min(3, lines.length); i++) {
            const line = lines[i].trim();
            if (line.match(/^-+(\s+-+)+$/)) {
                return true;
            }
        }
        return false;
    }

    // Function to detect if output is SHOW EVENTS format
    function isShowEventsData(data) {
        return data.includes('Event Types (number of events):') ||
               (data.includes('ActiveRecording') && data.includes('CPULoad') && data.includes('GarbageCollection'));
    }

    // Function to detect if output is SHOW FIELDS format
    function isShowFieldsData(data) {
        // Look for field definitions with type and name patterns
        return data.match(/^\s*(long|int|String|Thread|boolean|float|double|byte|short|char)\s+\w+/m) ||
               data.includes('Event types with a') ||
               data.includes(':') && data.match(/^\s*\w+\s+\w+$/m);
    }

    // Function to parse SHOW FIELDS output into formatted HTML
    function parseShowFieldsData(data) {
        const lines = data.split('\n');
        let html = '';
        let inEventSection = false;
        let currentEventName = '';
        let fields = [];
        let relatedEvents = [];

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            if (!line) continue;

            // Check if this is an event name (ends with colon)
            if (line.endsWith(':')) {
                // Process previous event if exists
                if (currentEventName && fields.length > 0) {
                    html += formatEventFields(currentEventName, fields);
                    fields = [];
                }

                currentEventName = line.slice(0, -1); // Remove colon
                inEventSection = false;
                continue;
            }

            // Check if this is a section header for related events
            if (line.includes('Event types with a') && line.includes('relation:')) {
                if (currentEventName && fields.length > 0) {
                    html += formatEventFields(currentEventName, fields);
                    fields = [];
                }
                html += `<div class="show-fields-section">
                    <h3>${escapeHtml(line)}</h3>
                </div>`;
                inEventSection = true;
                continue;
            }

            // If we're in the related events section
            if (inEventSection) {
                // Parse multiple event names from the line
                const eventNames = line.split(/\s+/).filter(name => name.trim() && !name.match(/^\s*$/));
                relatedEvents.push(...eventNames);
                continue;
            }

            // Parse field definition (type fieldName)
            const fieldMatch = line.match(/^\s*(long|int|String|Thread|boolean|float|double|byte|short|char|[\w.]+)\s+(\w+)/);
            if (fieldMatch) {
                fields.push({
                    type: fieldMatch[1],
                    name: fieldMatch[2]
                });
            }
        }

        // Process the last event
        if (currentEventName && fields.length > 0) {
            html += formatEventFields(currentEventName, fields);
        }

        // Add related events section if we have any
        if (relatedEvents.length > 0) {
            html += formatRelatedEvents(relatedEvents);
        }

        return html;
    }

    // Function to format event fields as a table
    function formatEventFields(eventName, fields) {
        let html = `<div class="show-fields-event">
            <h2>${escapeHtml(eventName)}</h2>
            <table class="jfr-table sortable-table show-fields-table">
                <thead>
                    <tr>
                        <th style="text-align: left" data-sort="string">Field Name <span class="sort-indicator"></span></th>
                        <th style="text-align: left" data-sort="string">Type <span class="sort-indicator"></span></th>
                    </tr>
                </thead>
                <tbody>`;

        for (const field of fields) {
            html += `<tr>
                <td style="text-align: left" data-value="${escapeHtml(field.name)}">${escapeHtml(field.name)}</td>
                <td style="text-align: left" data-value="${escapeHtml(field.type)}"><span class="field-type">${escapeHtml(field.type)}</span></td>
            </tr>`;
        }

        html += `    </tbody>
            </table>
        </div>`;

        return html;
    }

    // Function to format related events section
    function formatRelatedEvents(relatedEvents) {
        // Group events by prefix for better organization
        const grouped = {};
        relatedEvents.forEach(event => {
            const prefix = event.includes('.') ? event.split('.')[0] : 'other';
            if (!grouped[prefix]) grouped[prefix] = [];
            grouped[prefix].push(event);
        });

        let html = `<div class="show-fields-related">
            <table class="jfr-table sortable-table show-fields-related-table">
                <thead>
                    <tr>
                        <th style="text-align: left" data-sort="string">Related Event Types <span class="sort-indicator"></span></th>
                    </tr>
                </thead>
                <tbody>`;

        // Sort events alphabetically
        relatedEvents.sort().forEach(event => {
            html += `<tr>
                <td style="text-align: left" data-value="${escapeHtml(event)}">${escapeHtml(event)}</td>
            </tr>`;
        });

        html += `    </tbody>
            </table>
        </div>`;

        return html;
    }

    // Function to parse SHOW EVENTS output into HTML table (without Has Data column)
    function parseShowEventsData(data) {
        const lines = data.split('\n');
        const events = [];

        // Skip the header line and process the rest
        let startProcessing = false;

        for (const line of lines) {
            if (line.includes('Event Types (number of events):')) {
                startProcessing = true;
                continue;
            }

            if (!startProcessing || line.trim() === '') {
                continue;
            }

            // Parse each line - events can be in format "EventName (count)" or just "EventName"
            const eventMatches = line.match(/\b([A-Za-z][A-Za-z0-9_]*)\s*(\((\d+)\))?\s*/g);

            if (eventMatches) {
                for (const match of eventMatches) {
                    const eventMatch = match.trim().match(/^([A-Za-z][A-Za-z0-9_]*)\s*(\((\d+)\))?/);
                    if (eventMatch) {
                        const eventName = eventMatch[1];
                        const count = eventMatch[3] ? parseInt(eventMatch[3]) : 0;

                        events.push({
                            name: eventName,
                            count: count,
                            hasData: count > 0
                        });
                    }
                }
            }
        }

        // Sort events: first by whether they have data (count > 0), then alphabetically
        events.sort((a, b) => {
            if (a.hasData && !b.hasData) return -1;
            if (!a.hasData && b.hasData) return 1;
            return a.name.localeCompare(b.name);
        });

        // Generate HTML table
        let html = '<div class="show-events-summary">';

        const eventsWithData = events.filter(e => e.hasData);
        const eventsWithoutData = events.filter(e => !e.hasData);

        html += `<p><strong>Total Event Types:</strong> ${events.length} (${eventsWithData.length} with data, ${eventsWithoutData.length} without data)</p>`;
        html += '</div>';

        html += '<table class="jfr-table sortable-table show-events-table">';

        // Table header (removed Has Data column)
        html += '<thead><tr>';
        html += '<th style="text-align: left" data-sort="string">Event Type <span class="sort-indicator"></span></th>';
        html += '<th style="text-align: right" data-sort="number">Count <span class="sort-indicator"></span></th>';
        html += '</tr></thead>';

        // Table body
        html += '<tbody>';
        for (const event of events) {
            const rowClass = event.hasData ? 'has-data' : 'no-data';
            const countDisplay = event.count > 0 ? event.count.toLocaleString() : '-';

            html += `<tr class="${rowClass}">`;
            html += `<td style="text-align: left" data-value="${escapeHtml(event.name)}">${escapeHtml(event.name)}</td>`;
            html += `<td style="text-align: right" data-value="${event.count}">${countDisplay}</td>`;
            html += '</tr>';
        }
        html += '</tbody></table>';

        return html;
    }

    // Enhanced executeQuery to handle SHOW FIELDS formatting
    function executeQuery(addToHistory = false) {
        const query = queryInput.value;
        if (!query) return;

        // Hide autocompletion when executing query
        hideAutoCompleteSuggestions();

        // Skip if this exact query was just executed
        if (query === lastExecutedQuery) return;

        lastExecutedQuery = query;

        // Only add to history if explicitly requested (via button click)
        if (addToHistory && !previousQueries.has(query)) {
            previousQueries.add(query);
            updatePreviousQueriesDropdown();
        }

        document.getElementById('result').textContent = 'Executing query...';

        fetch(`/query?q=${encodeURIComponent(query)}`)
            .then(response => response.text())
            .then(data => {
                const resultDiv = document.getElementById('result');
                const formatOutputEnabled = document.getElementById('formatTables').checked;

                // Apply different formatting based on query type and format setting
                if (formatOutputEnabled && query.trim().toLowerCase() === 'views') {
                    resultDiv.innerHTML = highlightViewsOutput(data);
                } else if (formatOutputEnabled && query.trim().toUpperCase() === 'SHOW EVENTS' && isShowEventsData(data)) {
                    resultDiv.innerHTML = parseShowEventsData(data);
                } else if (formatOutputEnabled && query.trim().toUpperCase().startsWith('SHOW FIELDS') && isShowFieldsData(data)) {
                    resultDiv.innerHTML = parseShowFieldsData(data);
                } else if (formatOutputEnabled && isTabularData(data)) {
                    resultDiv.innerHTML = parseTabularData(data);
                } else {
                    resultDiv.textContent = data;
                }

                // Make tables sortable after rendering
                if (formatOutputEnabled) {
                    const tables = resultDiv.querySelectorAll('.sortable-table');
                    tables.forEach(table => makeSortable(table));
                }

                // Check if the error message contains a SHOW FIELDS suggestion
                checkAndExecuteShowFields(data);

                // If this was a SHOW EVENTS query, refresh our event types
                if (query.trim().toUpperCase() === 'SHOW EVENTS') {
                    setTimeout(loadAvailableEventTypes, 100);
                }
            })
            .catch(error => {
                document.getElementById('result').textContent = 'Error: ' + error;
            });
    }

    // Function to parse values with units for proper sorting
    function parseValueWithUnit(value) {
        if (!value || value === '-') return 0;

        const str = value.toString().trim();

        // Time units (convert to milliseconds for comparison)
        const timeMatch = str.match(/^(\d+(?:\.\d+)?)\s*(ns|μs|ms|s|m|h|d)$/i);
        if (timeMatch) {
            const num = parseFloat(timeMatch[1]);
            const unit = timeMatch[2].toLowerCase();

            switch (unit) {
                case 'ns': return num / 1000000; // nanoseconds to milliseconds
                case 'μs': return num / 1000;    // microseconds to milliseconds
                case 'ms': return num;           // milliseconds
                case 's': return num * 1000;     // seconds to milliseconds
                case 'm': return num * 60000;    // minutes to milliseconds
                case 'h': return num * 3600000;  // hours to milliseconds
                case 'd': return num * 86400000; // days to milliseconds
                default: return num;
            }
        }

        // Memory units (convert to bytes for comparison)
        const memoryMatch = str.match(/^(\d+(?:\.\d+)?)\s*(B|KB|MB|GB|TB|KiB|MiB|GiB|TiB)$/i);
        if (memoryMatch) {
            const num = parseFloat(memoryMatch[1]);
            const unit = memoryMatch[2].toLowerCase();

            switch (unit) {
                case 'b': return num;                    // bytes
                case 'kb': return num * 1000;           // kilobytes (decimal)
                case 'mb': return num * 1000000;        // megabytes (decimal)
                case 'gb': return num * 1000000000;     // gigabytes (decimal)
                case 'tb': return num * 1000000000000;  // terabytes (decimal)
                case 'kib': return num * 1024;          // kibibytes (binary)
                case 'mib': return num * 1048576;       // mebibytes (binary)
                case 'gib': return num * 1073741824;    // gibibytes (binary)
                case 'tib': return num * 1099511627776; // tebibytes (binary)
                default: return num;
            }
        }

        // Percentage values
        const percentMatch = str.match(/^(\d+(?:\.\d+)?)\s*%$/);
        if (percentMatch) {
            return parseFloat(percentMatch[1]);
        }

        // Regular numbers (including decimals)
        const numberMatch = str.match(/^(\d+(?:\.\d+)?)$/);
        if (numberMatch) {
            return parseFloat(numberMatch[1]);
        }

        // If no pattern matches, return 0 for consistent sorting
        return 0;
    }

    // Enhanced function to detect data types including units
    function detectDataType(values) {
        let hasNumbers = 0;
        let hasUnits = 0;
        let hasText = 0;

        for (const value of values) {
            if (!value || value === '-') continue;

            const str = value.toString().trim();

            // Check for time/memory units or percentages
            if (str.match(/^(\d+(?:\.\d+)?)\s*(ns|μs|ms|s|m|h|d|B|KB|MB|GB|TB|KiB|MiB|GiB|TiB|%)$/i)) {
                hasUnits++;
            }
            // Check for plain numbers
            else if (str.match(/^\d+(?:\.\d+)?$/)) {
                hasNumbers++;
            }
            // Everything else is text
            else {
                hasText++;
            }
        }

        // If most values have units, treat as numeric with units
        if (hasUnits > hasText && hasUnits > hasNumbers / 2) {
            return 'number';
        }
        // If most values are plain numbers, treat as numeric
        else if (hasNumbers > hasText) {
            return 'number';
        }
        // Otherwise treat as string
        else {
            return 'string';
        }
    }

    // Enhanced parseTabularData function with better data type detection
    function parseTabularData(data) {
        const lines = data.split('\n');
        let headerLine = '';
        let separatorLine = '';
        let dataLines = [];
        let separatorIndex = -1;

        // Find the separator line (line with dashes)
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line.match(/^-+(\s+-+)+$/)) {
                separatorIndex = i;
                separatorLine = line;
                if (i > 0) {
                    headerLine = lines[i - 1];
                }
                // Collect data lines after separator
                for (let j = i + 1; j < lines.length; j++) {
                    if (lines[j].trim()) {
                        dataLines.push(lines[j]);
                    }
                }
                break;
            }
        }

        if (separatorIndex === -1 || !headerLine) {
            return data; // Not a valid table format
        }

        // Parse column positions from separator line
        const columnPositions = [];
        let currentStart = -1;
        let inColumn = false;

        for (let i = 0; i < separatorLine.length; i++) {
            const char = separatorLine[i];
            if (char === '-') {
                if (!inColumn) {
                    inColumn = true;
                    currentStart = i;
                }
            } else if (char === ' ') {
                if (inColumn) {
                    columnPositions.push({
                        start: currentStart,
                        end: i - 1,
                        width: i - currentStart
                    });
                    inColumn = false;
                }
            }
        }

        // Add the last column if we ended in a column
        if (inColumn) {
            columnPositions.push({
                start: currentStart,
                end: separatorLine.length - 1,
                width: separatorLine.length - currentStart
            });
        }

        // Parse headers and determine alignment
        const headers = [];
        const alignments = [];

        for (const col of columnPositions) {
            const headerText = headerLine.substring(col.start, col.end + 1);
            const trimmedHeader = headerText.trim();
            headers.push(trimmedHeader);

            // Determine alignment based on header position within column
            const leadingSpaces = headerText.length - headerText.trimStart().length;
            const trailingSpaces = headerText.length - headerText.trimEnd().length;

            let alignment = 'left'; // default
            if (leadingSpaces > trailingSpaces) {
                alignment = 'right';
            } else if (leadingSpaces > 0 && trailingSpaces > 0 && Math.abs(leadingSpaces - trailingSpaces) <= 1) {
                alignment = 'center';
            }

            alignments.push(alignment);
        }

        // Parse data rows and collect column values for type detection
        const rows = [];
        const columnValues = headers.map(() => []); // Array of arrays to collect values per column

        for (const line of dataLines) {
            const row = [];
            for (let i = 0; i < columnPositions.length; i++) {
                const col = columnPositions[i];
                const cellText = line.substring(col.start, Math.min(col.end + 1, line.length));
                const trimmedCell = cellText.trim();
                row.push(trimmedCell);

                // Collect values for type detection
                if (trimmedCell) {
                    columnValues[i].push(trimmedCell);
                }

                // Refine alignment based on data content
                if (trimmedCell && alignments[i] === 'left') {
                    const leadingSpaces = cellText.length - cellText.trimStart().length;
                    const trailingSpaces = cellText.length - cellText.trimEnd().length;

                    // If most cells in this column are right-aligned, change alignment
                    if (leadingSpaces > trailingSpaces && leadingSpaces > 2) {
                        alignments[i] = 'right';
                    }
                }
            }
            rows.push(row);
        }

        // Detect data types for each column based on collected values
        const dataTypes = columnValues.map(values => detectDataType(values));

        // Generate HTML table with proper alignment and sorting
        let html = '<table class="jfr-table sortable-table">';

        // Table header
        html += '<thead><tr>';
        for (let i = 0; i < headers.length; i++) {
            const header = headers[i];
            const alignment = alignments[i];
            const dataType = dataTypes[i];
            html += `<th style="text-align: ${alignment}" data-sort="${dataType}">${escapeHtml(header)} <span class="sort-indicator"></span></th>`;
        }
        html += '</tr></thead>';

        // Table body
        html += '<tbody>';
        for (const row of rows) {
            html += '<tr>';
            for (let i = 0; i < row.length; i++) {
                const cell = row[i];
                const alignment = alignments[i];

                // Calculate sort value using the enhanced parser
                let sortValue = cell;
                if (dataTypes[i] === 'number') {
                    sortValue = parseValueWithUnit(cell);
                }

                html += `<td style="text-align: ${alignment}" data-value="${sortValue}">${escapeHtml(cell)}</td>`;
            }
            html += '</tr>';
        }
        html += '</tbody></table>';

        return html;
    }

    // Enhanced sort function to handle units properly
    function sortTable(table, columnIndex, dataType) {
        const tbody = table.querySelector('tbody');
        const rows = Array.from(tbody.querySelectorAll('tr'));
        const header = table.querySelectorAll('th')[columnIndex];
        const sortIndicator = header.querySelector('.sort-indicator');

        // Determine sort direction
        let ascending = true;
        if (header.classList.contains('sort-asc')) {
            ascending = false;
            header.classList.remove('sort-asc');
            header.classList.add('sort-desc');
            sortIndicator.textContent = ' ▼';
        } else {
            ascending = true;
            header.classList.remove('sort-desc');
            header.classList.add('sort-asc');
            sortIndicator.textContent = ' ▲';
        }

        // Clear other headers' sort indicators
        table.querySelectorAll('th').forEach((th, i) => {
            if (i !== columnIndex) {
                th.classList.remove('sort-asc', 'sort-desc');
                const indicator = th.querySelector('.sort-indicator');
                if (indicator) indicator.textContent = '';
            }
        });

        // Sort rows
        rows.sort((a, b) => {
            const aCell = a.children[columnIndex];
            const bCell = b.children[columnIndex];

            let aValue = aCell.getAttribute('data-value');
            let bValue = bCell.getAttribute('data-value');

            if (dataType === 'number') {
                // For numbers, use the pre-calculated sort values
                aValue = parseFloat(aValue) || 0;
                bValue = parseFloat(bValue) || 0;
                return ascending ? aValue - bValue : bValue - aValue;
            } else {
                // For strings, do case-insensitive comparison
                aValue = (aValue || aCell.textContent.trim()).toString().toLowerCase();
                bValue = (bValue || bCell.textContent.trim()).toString().toLowerCase();
                if (aValue < bValue) return ascending ? -1 : 1;
                if (aValue > bValue) return ascending ? 1 : -1;
                return 0;
            }
        });

        // Re-append sorted rows
        rows.forEach(row => tbody.appendChild(row));
    }

    // Function to make tables sortable
    function makeSortable(table) {
        const headers = table.querySelectorAll('th[data-sort]');

        headers.forEach((header, index) => {
            header.style.cursor = 'pointer';
            header.addEventListener('click', () => {
                sortTable(table, index, header.getAttribute('data-sort'));
            });
        });
    }

    // Enhanced executeQuery to initialize sortable tables
    function executeQuery(addToHistory = false) {
        const query = queryInput.value;
        if (!query) return;

        // Hide autocompletion when executing query
        hideAutoCompleteSuggestions();

        // Skip if this exact query was just executed
        if (query === lastExecutedQuery) return;

        lastExecutedQuery = query;

        // Only add to history if explicitly requested (via button click)
        if (addToHistory && !previousQueries.has(query)) {
            previousQueries.add(query);
            updatePreviousQueriesDropdown();
        }

        document.getElementById('result').textContent = 'Executing query...';

        fetch(`/query?q=${encodeURIComponent(query)}`)
            .then(response => response.text())
            .then(data => {
                const resultDiv = document.getElementById('result');
                const formatOutputEnabled = document.getElementById('formatTables').checked;

                // Apply different formatting based on query type and format setting
                if (formatOutputEnabled && query.trim().toLowerCase() === 'views') {
                    resultDiv.innerHTML = highlightViewsOutput(data);
                } else if (formatOutputEnabled && query.trim().toUpperCase() === 'SHOW EVENTS' && isShowEventsData(data)) {
                    resultDiv.innerHTML = parseShowEventsData(data);
                } else if (formatOutputEnabled && query.trim().toUpperCase().startsWith('SHOW FIELDS') && isShowFieldsData(data)) {
                    resultDiv.innerHTML = parseShowFieldsData(data);
                } else if (formatOutputEnabled && isTabularData(data)) {
                    resultDiv.innerHTML = parseTabularData(data);
                } else {
                    resultDiv.textContent = data;
                }

                // Make tables sortable after rendering
                if (formatOutputEnabled) {
                    const tables = resultDiv.querySelectorAll('.sortable-table');
                    tables.forEach(table => makeSortable(table));
                }

                // Check if the error message contains a SHOW FIELDS suggestion
                checkAndExecuteShowFields(data);

                // If this was a SHOW EVENTS query, refresh our event types
                if (query.trim().toUpperCase() === 'SHOW EVENTS') {
                    setTimeout(loadAvailableEventTypes, 100);
                }
            })
            .catch(error => {
                document.getElementById('result').textContent = 'Error: ' + error;
            });
    }

    // Enhanced function to load available event types dynamically
    async function loadAvailableEventTypes() {
        try {
            const response = await fetch('/query?q=' + encodeURIComponent('SHOW EVENTS'));
            const data = await response.text();

            // Parse the SHOW EVENTS output to extract event types with counts
            const eventTypes = [];
            const eventCounts = {}; // Store counts for display
            const lines = data.split('\n');

            for (const line of lines) {
                // Match patterns like "ActiveRecording (1)" or "CPULoad (184)"
                const match = line.match(/^\s*([A-Za-z][A-Za-z0-9_]*)\s*\((\d+)\)/);
                if (match) {
                    const eventName = match[1];
                    const count = parseInt(match[2]);

                    // Only include events that have actual data (count > 0)
                    if (count > 0) {
                        eventTypes.push(eventName);
                        eventCounts[eventName] = count;
                    }
                }
            }

            // Update the vocabulary with actual available events and their counts
            if (eventTypes.length > 0) {
                queryVocabulary.availableEventTypes = eventTypes;
                queryVocabulary.eventCounts = eventCounts;
                console.log(`Loaded ${eventTypes.length} event types with data:`, eventTypes);

                // Filter sample queries after loading events
                filterSampleQueriesByAvailableEvents();
            }

        } catch (error) {
            console.warn('Could not load event types, using fallback list:', error);
            // Keep the fallback list that's already in availableEventTypes
        }
    }

    // Enhanced filterSampleQueriesByAvailableEvents to also update dropdown
    function filterSampleQueriesByAvailableEvents() {
        const originalCount = queryVocabulary.sampleQueries.length;

        // Filter the sample queries to only include those with available events
        queryVocabulary.sampleQueries = queryVocabulary.sampleQueries.filter(query => {
            const queryText = typeof query === 'string' ? query : query.text;
            return isQueryValidForDataset(queryText);
        });

        const filteredCount = queryVocabulary.sampleQueries.length;
        console.log(`Filtered sample queries: ${originalCount} -> ${filteredCount} (removed ${originalCount - filteredCount} queries with unavailable events)`);

        // Also filter the previousQueries Set to remove invalid queries
        const previousQueriesList = Array.from(previousQueries);
        previousQueries.clear();

        previousQueriesList.forEach(query => {
            const queryText = typeof query === 'string' ? query : query.text;
            if (isQueryValidForDataset(queryText)) {
                previousQueries.add(query);
            }
        });

        // Update the dropdown with filtered queries
        updatePreviousQueriesDropdown();
    }

    // New function to check if a query references only available events
    function isQueryValidForDataset(queryText) {
        // Always allow non-event queries (SHOW commands, grammar, views, etc.)
        if (!queryText.includes('FROM') ||
            queryText.toLowerCase().includes('show ') ||
            queryText === 'grammar' ||
            queryText === 'views') {
            return true;
        }

        // Extract event names from FROM clauses
        const fromMatches = queryText.match(/FROM\s+([A-Za-z][A-Za-z0-9_.]*)/gi);
        if (!fromMatches) {
            return true; // No FROM clause found, allow it
        }

        // Check if all referenced events are in our available event types
        for (const fromMatch of fromMatches) {
            const eventName = fromMatch.replace(/FROM\s+/i, '').trim();

            // Check if this event is in our available events list
            if (!queryVocabulary.availableEventTypes.includes(eventName)) {
                return false; // Event not available in dataset
            }
        }

        return true; // All events are available
    }

    // Enhanced updatePreviousQueriesDropdown to filter by available events
    function updatePreviousQueriesDropdown() {
        const select = document.getElementById('previousQueries');

        // Clear existing options except the first one
        while (select.options.length > 1) {
            select.remove(1);
        }

        const specialOptions = ["grammar", "views"];
        specialOptions.forEach(query => {
            if (!previousQueries.has(query)) {
                const option = document.createElement('option');
                option.value = query;
                option.text = query;
                select.add(option);
            }
        });

        // Filter and sort queries from previousQueries Set
        Array.from(previousQueries).filter(query => {
            // Handle both string and object queries
            const queryText = typeof query === 'string' ? query : query.text;
            // Apply the same filtering logic as suggestions
            return isQueryValidForDataset(queryText);
        }).sort((a, b) => {
            // Handle both string and object queries for sorting
            const aText = typeof a === 'string' ? a : a.text;
            const bText = typeof b === 'string' ? b : b.text;
            return aText.localeCompare(bText);
        }).forEach(query => {
            const option = document.createElement('option');

            // Handle both string and object queries
            const queryText = typeof query === 'string' ? query : query.text;
            const queryDescription = typeof query === 'string' ? '' : query.description;

            option.value = queryText;

            // Create display text with description if available
            let displayText = queryText.length > 50 ? queryText.substring(0, 50) + '...' : queryText;
            if (queryDescription) {
                displayText += ` (${queryDescription})`;
            }

            option.text = displayText;
            select.add(option);
        });

        // Also add sample queries that are valid for the dataset
        queryVocabulary.sampleQueries.forEach(query => {
            const queryText = typeof query === 'string' ? query : query.text;
            const queryDescription = typeof query === 'string' ? '' : query.description;

            // Filter out queries that reference events not in the dataset
            if (!isQueryValidForDataset(queryText)) {
                return; // Skip this query
            }

            // Skip if already in previousQueries
            if (previousQueries.has(queryText) || previousQueries.has(query)) {
                return;
            }

            const option = document.createElement('option');
            option.value = queryText;

            // Create display text with description if available
            let displayText = queryText.length > 50 ? queryText.substring(0, 50) + '...' : queryText;
            if (queryDescription) {
                displayText += ` (${queryDescription})`;
            }

            option.text = displayText;
            select.add(option);
        });
    }

    // Enhanced function to add sample query suggestions - filter by available events
    function addSampleQuerySuggestions(suggestions, currentWord) {
        queryVocabulary.sampleQueries.forEach(query => {
            // Handle both string and object formats
            const queryText = typeof query === 'string' ? query : query.text;
            const queryType = typeof query === 'string' ? 'sample' : (query.type || 'sample');
            const queryDescription = typeof query === 'string' ? '' : (query.description || '');

            // Filter out queries that reference events not in the dataset
            if (!isQueryValidForDataset(queryText)) {
                return; // Skip this query
            }

            if (currentWord.length === 0 ||
                queryText.toLowerCase().includes(currentWord.toLowerCase())) {

                let description = queryDescription;
                if (!description && typeof query === 'string') {
                    // Generate description for string queries
                    if (queryText.includes('SHOW')) {
                        description = 'Show information';
                    } else if (queryText.includes('CAPTION')) {
                        description = 'Formatted report';
                    } else if (queryText.includes('SELECT') && queryText.includes('GROUP BY')) {
                        description = 'Aggregation query';
                    } else if (queryText.includes('SELECT')) {
                        description = 'Basic query';
                    } else if (queryText === 'grammar' || queryText === 'views') {
                        description = 'Help command';
                    }
                }

                suggestions.push({
                    text: queryText,
                    type: queryType,
                    description: description
                });
            }
        });
    }

    // Enhanced function to parse view.ini format and extract queries with descriptions
    function parseViewQueries(viewsData) {
        const viewQueries = [];
        const lines = viewsData.split('\n');
        let currentSection = null;
        let currentLabel = null;
        let inQuery = false;
        let queryLines = [];

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            // Skip comments and empty lines
            if (line.startsWith(';') || line === '') {
                continue;
            }

            // Section header like [environment.active-recordings]
            const sectionMatch = line.match(/^\[([^\]]+)\]$/);
            if (sectionMatch) {
                // Save previous query if exists
                if (currentSection && currentLabel && queryLines.length > 0) {
                    const fullQuery = queryLines.join(' ').trim();
                    if (fullQuery) {
                        const cleanQuery = extractCleanQuery(fullQuery);
                        viewQueries.push({
                            id: currentSection,
                            label: currentLabel,
                            fullQuery: fullQuery,
                            cleanQuery: cleanQuery,
                            category: currentSection.split('.')[0] // environment, application, jvm
                        });
                    }
                }

                currentSection = sectionMatch[1];
                currentLabel = null;
                queryLines = [];
                inQuery = false;
                continue;
            }

            // Label line
            const labelMatch = line.match(/^label\s*=\s*"([^"]+)"$/);
            if (labelMatch) {
                currentLabel = labelMatch[1];
                continue;
            }

            // Table or form query start
            const queryStartMatch = line.match(/^(table|form)\s*=\s*"(.*)$/);
            if (queryStartMatch) {
                inQuery = true;
                queryLines = [queryStartMatch[2]];
                continue;
            }

            // Continue multi-line query
            if (inQuery) {
                if (line.endsWith('"')) {
                    // End of query
                    queryLines.push(line.slice(0, -1));
                    inQuery = false;
                } else {
                    queryLines.push(line);
                }
            }
        }

        // Handle last query if file doesn't end with proper closure
        if (currentSection && currentLabel && queryLines.length > 0) {
            const fullQuery = queryLines.join(' ').trim();
            if (fullQuery) {
                const cleanQuery = extractCleanQuery(fullQuery);
                viewQueries.push({
                    id: currentSection,
                    label: currentLabel,
                    fullQuery: fullQuery,
                    cleanQuery: cleanQuery,
                    category: currentSection.split('.')[0]
                });
            }
        }

        return viewQueries;
    }

    // Function to extract clean query without COLUMN/FORMAT prefixes
    function extractCleanQuery(fullQuery) {
        // Remove COLUMN and FORMAT directives to get the core SQL
        let cleanQuery = fullQuery;

        // Remove COLUMN directive - handle multiline case
        cleanQuery = cleanQuery.replace(/^COLUMN\s+[^S]*?(SELECT)/i, '$1');

        // Remove FORMAT directive - handle multiline case
        cleanQuery = cleanQuery.replace(/FORMAT\s+[^S]*?(SELECT)/i, '$1');

        // Clean up extra whitespace
        cleanQuery = cleanQuery.replace(/\s+/g, ' ').trim();

        return cleanQuery;
    }

    // Function to create CAPTION version of a query
    function createCaptionQuery(viewQuery) {
        // Extract column names from COLUMN directive if present
        const columnMatch = viewQuery.fullQuery.match(/COLUMN\s+(.*?)\s+(?:FORMAT|SELECT)/is);
        if (columnMatch) {
            const columnDef = columnMatch[1].trim();
            // Create CAPTION version
            return `CAPTION ${columnDef} ${viewQuery.cleanQuery}`;
        }
        return null;
    }

    // Function to load view queries dynamically
    async function loadViewQueries() {
        try {
            const response = await fetch('/query?q=' + encodeURIComponent('views'));
            const data = await response.text();

            const viewQueries = parseViewQueries(data);

            if (viewQueries.length > 0) {
                console.log(`Loaded ${viewQueries.length} view queries`);

                // Add view queries to sample queries in multiple formats
                viewQueries.forEach(view => {
                    // Add the clean query (without COLUMN/FORMAT)
                    queryVocabulary.sampleQueries.push({
                        text: view.cleanQuery,
                        type: 'view',
                        description: view.label,
                        category: view.category,
                        id: view.id
                    });

                    // Add the full query (with COLUMN/FORMAT if present)
                    if (view.fullQuery !== view.cleanQuery) {
                        queryVocabulary.sampleQueries.push({
                            text: view.fullQuery,
                            type: 'view-formatted',
                            description: `${view.label} (formatted)`,
                            category: view.category,
                            id: view.id
                        });
                    }

                    // Add CAPTION version if COLUMN directive exists
                    const captionQuery = createCaptionQuery(view);
                    if (captionQuery) {
                        queryVocabulary.sampleQueries.push({
                            text: captionQuery,
                            type: 'view-caption',
                            description: `${view.label} (caption)`,
                            category: view.category,
                            id: view.id
                        });
                    }
                });

                console.log(`Added ${queryVocabulary.sampleQueries.filter(s => s.type?.startsWith('view')).length} view-based sample queries`);
            }

        } catch (error) {
            console.warn('Could not load view queries:', error);
        }
    }

    // Enhanced function to check for and execute SHOW FIELDS suggestions
    async function checkAndExecuteShowFields(errorMessage) {
        // Look for patterns like "SHOW FIELDS SomeEventName" in the error message
        const showFieldsMatch = errorMessage.match(/SHOW FIELDS\s+([A-Za-z][A-Za-z0-9_.]*)/);

        if (showFieldsMatch) {
            const eventName = showFieldsMatch[1];
            const showFieldsQuery = `SHOW FIELDS ${eventName}`;

            // Check cache first
            if (showFieldsCache.has(showFieldsQuery)) {
                console.log(`Using cached fields for: ${eventName}`);
                displayShowFieldsResult(showFieldsQuery, showFieldsCache.get(showFieldsQuery));
                return;
            }

            try {
                console.log(`Auto-executing: ${showFieldsQuery}`);
                const response = await fetch(`/query?q=${encodeURIComponent(showFieldsQuery)}`);
                const fieldsData = await response.text();

                // Use the enhanced cache function
                addToShowFieldsCache(showFieldsQuery, fieldsData);
                console.log(`Cached fields for: ${eventName}`);

                // Display the fields information
                displayShowFieldsResult(showFieldsQuery, fieldsData);

            } catch (error) {
                console.warn('Failed to auto-execute SHOW FIELDS:', error);
                const resultDiv = document.getElementById('result');
                const currentContent = resultDiv.textContent;
                resultDiv.textContent = currentContent + `\n\nFailed to auto-execute: ${showFieldsQuery}`;
            }
        }
    }

    // Function to display SHOW FIELDS results below the error message
    function displayShowFieldsResult(query, fieldsData) {
        const resultDiv = document.getElementById('result');
        const currentContent = resultDiv.textContent;

        // Create a separator and add the fields information
        const separator = '\n\n' + '='.repeat(50) + '\n';
        const fieldsSection = `Auto-executed: ${query}\n${separator}${fieldsData}`;

        resultDiv.textContent = currentContent + '\n\n' + fieldsSection;

        // Scroll to show the new content
        resultDiv.scrollTop = resultDiv.scrollHeight;
    }

    // Enhanced cache management - add function to get cache statistics
    function getShowFieldsCacheStats() {
        console.log(`SHOW FIELDS cache contains ${showFieldsCache.size} entries:`);
        for (const [query, data] of showFieldsCache.entries()) {
            console.log(`- ${query}: ${data.length} characters`);
        }
    }

    // Enhanced cache clear function with statistics
    function clearShowFieldsCache() {
        const size = showFieldsCache.size;
        showFieldsCache.clear();
        console.log(`SHOW FIELDS cache cleared (${size} entries removed)`);
    }

    // Optional: Add cache size limit to prevent memory issues
    const MAX_CACHE_SIZE = 50; // Maximum number of cached SHOW FIELDS results

    function addToShowFieldsCache(query, data) {
        // If cache is at limit, remove oldest entry (simple LRU)
        if (showFieldsCache.size >= MAX_CACHE_SIZE) {
            const firstKey = showFieldsCache.keys().next().value;
            showFieldsCache.delete(firstKey);
            console.log(`Cache limit reached, removed: ${firstKey}`);
        }

        showFieldsCache.set(query, data);
    }

    // Initialize sample queries - only add strings to previousQueries Set
    queryVocabulary.sampleQueries.forEach(query => {
        // Only add string queries to the dropdown, skip objects
        if (typeof query === 'string') {
            previousQueries.add(query);
        } else {
            // For object queries, add just the text part
            previousQueries.add(query.text);
        }
    });

    // Enhanced function to add sample query suggestions
    function addSampleQuerySuggestions(suggestions, currentWord) {
        queryVocabulary.sampleQueries.forEach(query => {
            // Handle both string and object formats
            const queryText = typeof query === 'string' ? query : query.text;
            const queryType = typeof query === 'string' ? 'sample' : (query.type || 'sample');
            const queryDescription = typeof query === 'string' ? '' : (query.description || '');

            if (currentWord.length === 0 ||
                queryText.toLowerCase().includes(currentWord.toLowerCase())) {

                let description = queryDescription;
                if (!description && typeof query === 'string') {
                    // Generate description for string queries
                    if (queryText.includes('SHOW')) {
                        description = 'Show information';
                    } else if (queryText.includes('CAPTION')) {
                        description = 'Formatted report';
                    } else if (queryText.includes('SELECT') && queryText.includes('GROUP BY')) {
                        description = 'Aggregation query';
                    } else if (queryText.includes('SELECT')) {
                        description = 'Basic query';
                    } else if (queryText === 'grammar' || queryText === 'views') {
                        description = 'Help command';
                    }
                }

                suggestions.push({
                    text: queryText,
                    type: queryType,
                    description: description
                });
            }
        });
    }

    // Enhanced auto-completion function with better sample query logic
    function getAutoCompleteSuggestions(text, cursorPos) {
        const beforeCursor = text.substring(0, cursorPos);
        const wordMatch = beforeCursor.match(/\b\w*$/);
        const currentWord = wordMatch ? wordMatch[0].toLowerCase() : '';

        const suggestions = [];
        const context = getQueryContext(beforeCursor);

        // Add sample queries when at the start or for short inputs
        if (beforeCursor.trim().length < 10 || context === 'start') {
            addSampleQuerySuggestions(suggestions, currentWord);
        }

        // Add context-specific suggestions
        switch (context) {
            case 'start':
            case 'after_keyword':
                addSuggestions(suggestions, queryVocabulary.keywords, currentWord, 'keyword');
                break;
            case 'after_select':
                addSuggestions(suggestions, queryVocabulary.functions, currentWord, 'function');
                addSuggestions(suggestions, queryVocabulary.commonFields, currentWord, 'field');
                break;
            case 'after_from':
                addEventSuggestions(suggestions, queryVocabulary.availableEventTypes, currentWord);
                break;
            case 'after_format':
                addSuggestions(suggestions, queryVocabulary.formatProperties, currentWord, 'property');
                break;
            default:
                addSuggestions(suggestions, queryVocabulary.keywords, currentWord, 'keyword');
                addSuggestions(suggestions, queryVocabulary.functions, currentWord, 'function');
                addSuggestions(suggestions, queryVocabulary.commonFields, currentWord, 'field');
                addEventSuggestions(suggestions, queryVocabulary.availableEventTypes, currentWord);
        }

        // Sort suggestions - DON'T prioritize view queries, keep them mixed in
        suggestions.sort((a, b) => {
            const trimmedInput = beforeCursor.trim().toLowerCase();

            // Prioritize exact matches from the beginning
            const aStartsWithInput = a.text.toLowerCase().startsWith(trimmedInput);
            const bStartsWithInput = b.text.toLowerCase().startsWith(trimmedInput);

            if (aStartsWithInput && !bStartsWithInput) return -1;
            if (!aStartsWithInput && bStartsWithInput) return 1;

            // Otherwise keep original order (mixed)
            return 0;
        });

        return suggestions.slice(0, 20);
    }

    // New function to add event suggestions with counts
    function addEventSuggestions(suggestions, eventTypes, currentWord) {
        eventTypes.forEach(eventType => {
            if (eventType.toLowerCase().includes(currentWord.toLowerCase()) ||
                eventType.toLowerCase().startsWith(currentWord.toLowerCase())) {
                const count = queryVocabulary.eventCounts && queryVocabulary.eventCounts[eventType]
                    ? queryVocabulary.eventCounts[eventType]
                    : '';

                suggestions.push({
                    text: eventType,
                    type: 'event',
                    count: count,
                    description: count ? `${count} events` : ''
                });
            }
        });
    }

    // Enhanced suggestion display to show counts and descriptions
    function showAutoCompleteSuggestions(suggestions) {
        if (suggestions.length === 0) {
            hideAutoCompleteSuggestions();
            return;
        }

        currentSuggestions = suggestions;
        selectedSuggestionIndex = -1; // Don't preselect any suggestion

        const html = suggestions.map((suggestion, index) => {
            let displayText = suggestion.text;
            let metaInfo = '';

            // Format based on suggestion type
            if (suggestion.type === 'event' && suggestion.count) {
                metaInfo = `<span class="suggestion-count">${suggestion.count} events</span>`;
            } else if (suggestion.description) {
                metaInfo = `<span class="suggestion-description">${suggestion.description}</span>`;
            }

            // Truncate very long queries for display
            if ((suggestion.type?.startsWith('view') || suggestion.type === 'sample') && displayText.length > 80) {
                displayText = displayText.substring(0, 80) + '...';
            }

            return `<div class="autocomplete-suggestion" data-index="${index}">
                <div class="suggestion-main">
                    <div class="suggestion-text">${displayText}</div>
                    <div class="suggestion-meta">
                        <span class="autocomplete-suggestion-type">${suggestion.type}</span>
                        ${metaInfo}
                    </div>
                </div>
            </div>`;
        }).join('');

        autocompleteSuggestions.innerHTML = html;
        autocompleteSuggestions.style.display = 'block';

        // Add click handlers
        autocompleteSuggestions.querySelectorAll('.autocomplete-suggestion').forEach(elem => {
            elem.addEventListener('click', () => {
                applySuggestion(suggestions[parseInt(elem.dataset.index)]);
            });
        });
    }

    // Enhanced applySuggestion to handle sample queries better
    function applySuggestion(suggestion) {
        const cursorPos = queryInput.selectionStart;
        const text = queryInput.value;
        const beforeCursor = text.substring(0, cursorPos);
        const afterCursor = text.substring(cursorPos);

        let newText, newPos;

        // For sample queries, replace the entire query if we're at the start
        if (suggestion.type === 'sample' && beforeCursor.trim().length < 10) {
            newText = suggestion.text;
            newPos = suggestion.text.length;
        } else {
            // For other suggestions, find the current partial word
            const wordMatch = beforeCursor.match(/\b\w*$/);
            const wordStart = wordMatch ? cursorPos - wordMatch[0].length : cursorPos;

            // Replace the partial word with the suggestion
            newText = text.substring(0, wordStart) + suggestion.text + afterCursor;
            newPos = wordStart + suggestion.text.length;
        }

        queryInput.value = newText;
        queryInput.setSelectionRange(newPos, newPos);

        hideAutoCompleteSuggestions();
        updateHighlighting();
        queryInput.focus();
    }

    function getQueryContext(beforeCursor) {
        const trimmed = beforeCursor.trim().toLowerCase();

        if (trimmed === '' || /^\s*$/.test(trimmed)) return 'start';
        if (/\bselect\s*$/i.test(trimmed)) return 'after_select';
        if (/\bfrom\s*$/i.test(trimmed)) return 'after_from';
        if (/\bformat\s*$/i.test(trimmed)) return 'after_format';
        if (/\bwhere\s*$/i.test(trimmed)) return 'after_where';
        if (/\bgroup\s+by\s*$/i.test(trimmed)) return 'after_group_by';
        if (/\border\s+by\s*$/i.test(trimmed)) return 'after_order_by';

        return 'general';
    }

    function addSuggestions(suggestions, items, currentWord, type) {
        items.forEach(item => {
            if (item.toLowerCase().startsWith(currentWord)) {
                suggestions.push({ text: item, type: type });
            }
        });
    }

    function hideAutoCompleteSuggestions() {
        autocompleteSuggestions.style.display = 'none';
        currentSuggestions = [];
        selectedSuggestionIndex = -1;
    }

    // Update navigateSuggestions to handle the case where no suggestion is initially selected
    function navigateSuggestions(direction) {
        if (currentSuggestions.length === 0) return;

        // Remove previous selection
        if (selectedSuggestionIndex >= 0) {
            const prevSelected = autocompleteSuggestions.children[selectedSuggestionIndex];
            if (prevSelected) {
                prevSelected.classList.remove('selected');
            }
        }

        // Update selection
        if (selectedSuggestionIndex === -1) {
            // If no selection, start from first (down) or last (up)
            selectedSuggestionIndex = direction > 0 ? 0 : currentSuggestions.length - 1;
        } else {
            selectedSuggestionIndex += direction;
            if (selectedSuggestionIndex < 0) {
                selectedSuggestionIndex = currentSuggestions.length - 1;
            } else if (selectedSuggestionIndex >= currentSuggestions.length) {
                selectedSuggestionIndex = 0;
            }
        }

        // Add new selection
        const newSelected = autocompleteSuggestions.children[selectedSuggestionIndex];
        if (newSelected) {
            newSelected.classList.add('selected');
            newSelected.scrollIntoView({ block: 'nearest' });
        }
    }

    // Update the format output checkbox handler
    document.getElementById('formatTables').addEventListener('change', function() {
        // If there's a current query result, re-process it
        const resultDiv = document.getElementById('result');
        const currentContent = resultDiv.textContent || resultDiv.innerHTML;

        // Only re-execute if we have a last executed query and it's not empty
        if (lastExecutedQuery &&
            currentContent !== 'Executing query...' &&
            currentContent !== 'Results will appear here' &&
            currentContent !== 'Re-formatting...') {

            // Re-execute the last query to apply/remove output formatting
            const query = lastExecutedQuery;
            document.getElementById('result').textContent = 'Re-formatting...';

            fetch(`/query?q=${encodeURIComponent(query)}`)
                .then(response => response.text())
                .then(data => {
                    const formatOutputEnabled = this.checked;

                    if (formatOutputEnabled && query.trim().toLowerCase() === 'views') {
                        resultDiv.innerHTML = highlightViewsOutput(data);
                    } else if (formatOutputEnabled && query.trim().toUpperCase() === 'SHOW EVENTS' && isShowEventsData(data)) {
                        resultDiv.innerHTML = parseShowEventsData(data);
                    } else if (formatOutputEnabled && query.trim().toUpperCase().startsWith('SHOW FIELDS') && isShowFieldsData(data)) {
                        resultDiv.innerHTML = parseShowFieldsData(data);
                    } else if (formatOutputEnabled && isTabularData(data)) {
                        resultDiv.innerHTML = parseTabularData(data);
                    } else {
                        resultDiv.textContent = data;
                    }
                })
                .catch(error => {
                    resultDiv.textContent = 'Error: ' + error;
                });
        }
    });

    // Function to highlight the views output with syntax highlighting
    function highlightViewsOutput(viewsData) {
        const lines = viewsData.split('\n');
        const highlightedLines = [];
        let inQuery = false;
        let queryLines = [];

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];

            // Check if this is a section header
            if (line.match(/^\[([^\]]+)\]$/)) {
                // If we were in a query, highlight it first
                if (inQuery && queryLines.length > 0) {
                    const queryText = queryLines.join('\n');
                    const highlighted = highlightSyntax(queryText);
                    highlightedLines.push(highlighted);
                    queryLines = [];
                    inQuery = false;
                }

                // Add the section header with special styling
                highlightedLines.push(`<span class="view-section">${escapeHtml(line)}</span>`);
                continue;
            }

            // Check if this is a label line
            if (line.match(/^label\s*=\s*"([^"]+)"$/)) {
                highlightedLines.push(`<span class="view-label">${escapeHtml(line)}</span>`);
                continue;
            }

            // Check if this starts a query
            if (line.match(/^(table|form)\s*=\s*"/)) {
                inQuery = true;
                queryLines = [line];
                continue;
            }

            // If we're in a query, collect lines
            if (inQuery) {
                queryLines.push(line);

                // Check if this ends the query
                if (line.trim().endsWith('"')) {
                    // Highlight the complete query
                    const queryText = queryLines.join('\n');
                    const highlighted = highlightViewsQuery(queryText);
                    highlightedLines.push(highlighted);
                    queryLines = [];
                    inQuery = false;
                }
                continue;
            }

            // For other lines (comments, etc.), just escape and add
            if (line.trim().startsWith(';')) {
                highlightedLines.push(`<span class="view-comment">${escapeHtml(line)}</span>`);
            } else if (line.trim() === '') {
                highlightedLines.push('');
            } else {
                highlightedLines.push(escapeHtml(line));
            }
        }

        // Handle any remaining query at the end
        if (inQuery && queryLines.length > 0) {
            const queryText = queryLines.join('\n');
            const highlighted = highlightViewsQuery(queryText);
            highlightedLines.push(highlighted);
        }

        return highlightedLines.join('\n');
    }

    // Function to highlight a query within the views output
    function highlightViewsQuery(queryText) {
        // Extract the SQL part from the query definition
        let sqlPart = queryText;

        // Split into lines to handle the structure
        const lines = queryText.split('\n');
        const highlightedLines = [];

        for (const line of lines) {
            if (line.match(/^(table|form)\s*=\s*"/)) {
                // This is the start line
                const match = line.match(/^((table|form)\s*=\s*")(.*)/);
                if (match) {
                    const prefix = match[1];
                    const sqlStart = match[3];
                    highlightedLines.push(
                        `<span class="view-query-type">${escapeHtml(prefix)}</span>` +
                        (sqlStart ? highlightSyntax(sqlStart) : '')
                    );
                } else {
                    highlightedLines.push(escapeHtml(line));
                }
            } else if (line.trim().endsWith('"')) {
                // This is the end line
                const sqlEnd = line.substring(0, line.lastIndexOf('"'));
                const quote = '"';
                highlightedLines.push(
                    (sqlEnd ? highlightSyntax(sqlEnd) : '') +
                    `<span class="view-query-type">${escapeHtml(quote)}</span>`
                );
            } else {
                // This is a middle line with SQL content
                if (line.trim()) {
                    highlightedLines.push(highlightSyntax(line));
                } else {
                    highlightedLines.push(line);
                }
            }
        }

        return highlightedLines.join('\n');
    }

    // Helper function to escape HTML
    function escapeHtml(text) {
        return text.replace(/[<>&"']/g, function(match) {
            return {
                '<': '&lt;',
                '>': '&gt;',
                '&': '&amp;',
                '"': '&quot;',
                "'": '&#39;'
            }[match];
        });
    }

    // Function for selecting previous queries from dropdown
    function selectPreviousQuery() {
        const select = document.getElementById('previousQueries');
        const query = select.value;
        if (query) {
            queryInput.value = query;
            select.selectedIndex = 0;
            updateHighlighting(); // Trigger highlighting update

            if (document.getElementById('autoQuery').checked) {
                executeQuery(false);
            }
        }
    }

    // Auto-query functionality
    function checkAndExecuteQuery() {
        const query = queryInput.value;
        if (query && query !== lastExecutedQuery) {
            // Don't add to history during auto-query
            executeQuery(false);
        }
    }

    // Handle auto-query checkbox
    document.getElementById('autoQuery').addEventListener('change', function() {
        if (this.checked) {
            autoQueryInterval = setInterval(checkAndExecuteQuery, 1000);
        } else {
            if (autoQueryInterval) {
                clearInterval(autoQueryInterval);
                autoQueryInterval = null;
            }
        }
    });

    // Hide suggestions when clicking outside
    document.addEventListener('click', function(e) {
        if (!e.target.closest('.autocomplete-container')) {
            hideAutoCompleteSuggestions();
        }
    });

    // Load event types and view queries when the page loads
    window.addEventListener('load', function() {
        loadAvailableEventTypes();
        loadViewQueries();
    });

    // Initialize everything
    updatePreviousQueriesDropdown();

    // Initialize syntax highlighter
    const highlighterElements = createSyntaxHighlighter();
    queryInput = highlighterElements.queryInput;
    highlightDiv = highlighterElements.highlightDiv;
    autocompleteSuggestions = document.getElementById('autocompleteSuggestions');

    // Event listeners
    queryInput.addEventListener('input', function(e) {
        updateHighlighting();

        const suggestions = getAutoCompleteSuggestions(queryInput.value, queryInput.selectionStart);
        showAutoCompleteSuggestions(suggestions);
    });

    queryInput.addEventListener('scroll', function() {
        highlightDiv.scrollTop = queryInput.scrollTop;
        highlightDiv.scrollLeft = queryInput.scrollLeft;
    });

    queryInput.addEventListener('keydown', function(e) {
        if (autocompleteSuggestions && autocompleteSuggestions.style.display === 'block') {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                navigateSuggestions(1);
                return;
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                navigateSuggestions(-1);
                return;
            } else if (e.key === 'Tab') {
                e.preventDefault();
                if (currentSuggestions.length > 0) {
                    if (selectedSuggestionIndex === -1) {
                        // If no suggestion is selected, select the first one
                        selectedSuggestionIndex = 0;
                        const firstSuggestion = autocompleteSuggestions.children[0];
                        if (firstSuggestion) {
                            firstSuggestion.classList.add('selected');
                        }
                    } else {
                        // Tab cycles forward, Shift+Tab cycles backward
                        navigateSuggestions(e.shiftKey ? -1 : 1);
                    }
                }
                return;
            } else if (e.key === 'Enter' && selectedSuggestionIndex >= 0) {
                e.preventDefault();
                applySuggestion(currentSuggestions[selectedSuggestionIndex]);
                return;
            } else if (e.key === 'Escape') {
                hideAutoCompleteSuggestions();
                return;
            }
        }

        if ((e.key === 'Enter' || e.keyCode === 13) && (e.ctrlKey || e.metaKey)) {
            console.log('Ctrl+Enter pressed, executing query...');
            // Hide autocompletion before executing
            hideAutoCompleteSuggestions();
            executeQuery(true);
            e.preventDefault();
            return false;
        }
    });

    // Initial highlighting    updateHighlighting();
</script>
</body>
</html>